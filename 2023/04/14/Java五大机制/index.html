<!DOCTYPE html>
<html lang="zh-Hans">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="x5-fullscreen" content="true">
<meta name="full-screen" content="yes">
<meta name="theme-color" content="#317EFB" />
<meta content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=0" name="viewport">
<meta name="description" content="对于Java五大机制的讲解，包括反射、泛型、注解、异常、SPI机制">
<meta property="og:type" content="article">
<meta property="og:title" content="Java五大机制">
<meta property="og:url" content="https://deep-learn.top/2023/04/14/Java%E4%BA%94%E5%A4%A7%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Octopus">
<meta property="og:description" content="对于Java五大机制的讲解，包括反射、泛型、注解、异常、SPI机制">
<meta property="og:locale">
<meta property="og:image" content="https://deep-learn.top/img/404.jpg">
<meta property="article:published_time" content="2023-04-14T01:50:20.000Z">
<meta property="article:modified_time" content="2023-04-22T07:32:17.354Z">
<meta property="article:author" content="Deep Octopus">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://deep-learn.top/img/404.jpg">

    <meta name="keywords" content="Java">


<title >Java五大机制</title>

<!-- Favicon -->

    <link href='/images/energy16.png?v=2.0.4' rel='icon' type='image/png' sizes='16x16' ></link>


    <link href='/images/energy32.png?v=2.0.4' rel='icon' type='image/png' sizes='32x32' ></link>




<!-- Plugin -->




    
<link rel="stylesheet" href="/css/plugins/bootstrap.row.css">

    
<link rel="stylesheet" href="https://npm.elemecdn.com/locomotive-scroll@4.1.4/dist/locomotive-scroll.min.css">

    
<link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui@4.0/dist/fancybox.css">

    
    
<link rel="stylesheet" href="https://npm.elemecdn.com/katex@latest/dist/katex.min.css">





<!-- Icon -->

    
<link rel="stylesheet" href="//at.alicdn.com/t/c/font_3975750_ub8ok6z2a8.css">




<!-- Variable -->
<script>window.ASYNC_CONFIG = {"hostname":"deep-learn.top","author":"Deep Octopus","root":"/","typed_text":null,"theme_version":"2.0.4","theme":{"switch":true,"default":"style-light"},"favicon":{"logo":"images/energy32.png","icon16":"images/energy16.png","icon32":"images/energy32.png","appleTouchIcon":null,"webmanifest":null,"visibilitychange":true,"hidden":"images/energy16.png","showText":"(/≧▽≦/)咦！又好了！","hideText":"(●—●)喔哟，崩溃啦！"},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）","author":"本文作者：","copyright_link":"本文链接：","copyright_license_title":"版权声明：","copyright_license_content":"本博客所有文章除特别声明外，均默认采用 undefined 许可协议。","copy_success":"复制成功","copy_failure":"复制失败","open_read_mode":"进入阅读模式","exit_read_mode":"退出阅读模式","notice_outdate_message":"距离上次更新已经 undefined 天了, 文章内容可能已经过时。","just":"刚刚","min":"分钟前","hour":"小时前","day":"天前","month":"个月前"},"swup":false,"plugin":{"flickr_justified_gallery":"https://npm.elemecdn.com/flickr-justified-gallery@latest/dist/fjGallery.min.js"},"icons":{"sun":"far fa-sun","moon":"far fa-moon","play":"fas fa-play","email":"far fa-envelope","next":"fas fa-arrow-right","calendar":"far fa-calendar-alt","clock":"far fa-clock","user":"far fa-user","back_top":"fas fa-arrow-up","close":"fas fa-times","search":"fas fa-search","reward":"fas fa-hand-holding-usd","user_tag":"fas fa-user-alt","toc_tag":"fas fa-th-list","read":"fas fa-book-reader","arrows":"fas fa-arrows-alt-h","double_arrows":"fas fa-angle-double-down","copy":"fas fa-copy"},"icontype":"font","highlight":{"plugin":"highlighjs","theme":true,"copy":true,"lang":true,"title":"mac","height_limit":10000},"creative_commons":{"license":"by-nc-sa","language":"deed.zh"}};</script>
<script id="async-page-config">window.PAGE_CONFIG = {"isPost":true,"isHome":false,"postUpdate":"2023-04-22 15:32:17"};</script>

<!-- Theme mode css -->
<link data-swup-theme rel="stylesheet" href="/css/index.css?v=2.0.4" id="trm-switch-style">
<script>
    let defaultMode = ASYNC_CONFIG.theme.default !=='auto' ?  ASYNC_CONFIG.theme.default : (window.matchMedia("(prefers-color-scheme: light)").matches ? 'style-light' : 'style-dark')
    let catchMode = localStorage.getItem('theme-mode') || defaultMode;
    let type = catchMode === 'style-dark' ? 'add' : 'remove';
    document.documentElement.classList[type]('dark')
</script>

<!-- CDN -->


    
    



<!-- Site Analytics -->

    
        <!-- Baidu Analytics -->
        <script defer>
            var _hmt = _hmt || [];
            (function() {
              var hm = document.createElement("script");
              hm.src = "https://hm.baidu.com/hm.js?24e69222a4eb2ea8339af0d51bd99a47";
              var s = document.getElementsByTagName("script")[0]; 
              s.parentNode.insertBefore(hm, s);
            })();
        </script>
     

    

    
 
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body>

  <!-- app wrapper -->
  <div class="trm-app-frame">

    <!-- page preloader -->
    <div class="trm-preloader">
    <div class="trm-holder">
        <div class="preloader">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
</div>
    <!-- page preloader end -->

    <!-- change mode preloader -->
    <div class="trm-mode-swich-animation-frame">
    <div class="trm-mode-swich-animation">
        <i class="i-sun"><i class="iconfont far fa-sun"></i></i>
        <div class="trm-horizon"></div>
        <i class="i-moon"><i class="iconfont far fa-moon"></i></i>
    </div>
</div>
    <!-- change mode preloader end -->

      <!-- scroll container -->
      <div id="trm-dynamic-content" class="trm-swup-animation">
        <div id="trm-scroll-container" class="trm-scroll-container" data-scroll-container style="opacity: 0">
          <div data-scroll-section id="content" class="trm-scroll-section">

            <div class="locomotive-scroll__sticky-target" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none;"></div>

            <!-- top bar -->
            <header class="trm-top-bar" data-scroll data-scroll-sticky data-scroll-target=".locomotive-scroll__sticky-target" data-scroll-offset="-10">
	<div class="container">
		<div class="trm-left-side">
			<!-- logo -->
<a href="/" class="trm-logo-frame trm-anima-link">
    
        <img alt="logo" src="/images/energy32.png">
    
    
        <div class="trm-logo-text">
            DEEP<span>LEARN</span>
        </div>
    
</a>
<!-- logo end -->
		</div>
		<div class="trm-right-side">
			<!-- menu -->
<div class="trm-menu">
    <nav>
        <ul>
            
            <li class="menu-item-has-children ">
                <a  href="/" target="">
                    首页
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a data-no-swup href="/archives/" target="">
                    归档
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a data-no-swup href="/category/" target="">
                    分类
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a data-no-swup href="/tags/" target="">
                    标签
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a data-no-swup href="/links/" target="">
                    友情链接
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a data-no-swup href="/about/" target="">
                    关于
                </a>
                
            </li>
            
        </ul>
    </nav>
</div>
<!-- menu end -->
			
    <!-- mode switcher place -->
    <div class="trm-mode-switcher-place">
        <div class="trm-mode-switcher">
            <i class="iconfont far fa-sun"></i>
            <input class="tgl tgl-light" id="trm-swich" type="checkbox">
            <label class="trm-swich" for="trm-swich"></label>
            <i class="iconfont far fa-moon"></i>
        </div>
    </div>
    <!-- mode switcher place end -->

			
    
        <a id="trm-search-btn" class="trm-search-btn" data-no-swup target="_blank" href="https://www.baidu.com/s?wd=site:www.imalun.com">
            <i class="iconfont fas fa-search"></i>
        </a>
     

		</div>
		<div class="trm-menu-btn">
			<span></span>
		</div>
	</div>
</header>
            <!-- top bar end -->

            <!-- body -->
            
<div class="trm-content-start">
    <!-- banner -->
    <div class="trm-banner" data-scroll data-scroll-direction="vertical">
    
    <!-- banner cover -->
    <img style="object-position:top;object-fit:cover;" alt="banner" class="trm-banner-cover" data-scroll data-scroll-direction="vertical" data-scroll-speed="-3" src="/img/banner.png">
    <!-- banner cover end -->
    

    <!-- banner content -->
    <div class="trm-banner-content trm-overlay">
        <div class="container" data-scroll data-scroll-direction="vertical" data-scroll-speed="0">
            <div class="row">
                
                <div class="col-lg-4"></div>
                
                <div class="col-lg-8">

                    <!-- banner title -->
                    <div class="trm-banner-text ">
                        <div class="trm-label trm-mb-20">
                            NEWS LETTER
                        </div>
                        <h1 class="trm-mb-30 trm-hsmb-font">
                            Java五大机制
                        </h1>

                        
                            <ul class="trm-breadcrumbs trm-label">
                                <li>
                                    <a href="/" class="trm-anima-link">Home</a>
                                </li>
                                <li>
                                    <span>
                                        2023
                                    </span
                                ></li>
                            </ul>
                        
                    </div>
                    <!-- banner title end -->

                    <!-- scroll hint -->
                    <a href="#about-triger" data-scroll-to="#about-triger" data-scroll-offset="-130" class="trm-scroll-hint-frame">
                        <div class="trm-scroll-hint"></div>
                        <span class="trm-label">Scroll down</span>
                    </a>
                    <!-- scroll hint end -->

                </div>
            </div>
        </div>
    </div>
    <!-- banner content end -->
</div>
    <!-- banner end -->
    <div class="container">
        <div class="row">
            
                <div id="page-sidebar" class="col-lg-4 hidden-sm">
                    <!-- main card -->
                    

<div class="trm-main-card-frame trm-sidebar">
    <div class="trm-main-card" data-scroll data-scroll-repeat data-scroll-sticky data-scroll-target=".locomotive-scroll__sticky-target" data-scroll-offset="60"> 
    
        <div class="trm-user-tabs" id="sidebar-tabs">
           <div class="trm-tabs-nav trm-mb-40" id="trm-tabs-nav">
                <div data-to="tabs-user" class="trm-tabs-nav-item">
                    <i class="iconfont fas fa-user-alt"></i>
                </div>
                <div data-to="tabs-toc" class="trm-tabs-nav-item active">
                    <i class="iconfont fas fa-th-list"></i>
                </div>
           </div>
            <div name="tabs-user" class="trm-tabs-item">
                <!-- card header -->
<div class="trm-mc-header">
    <div class="trm-avatar-frame trm-mb-20">
        <img alt="Avatar" class="trm-avatar" src="/images/ava2.jpg">
    </div>
    <h5 class="trm-name trm-mb-15">
        一个很闲的vegetable
    </h5>
    
</div>
<!-- card header end -->
                <!-- sidebar social -->

<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<div class="trm-social">
    
        <a href="https://github.com" title="Github" rel="nofollow" target="_blank">
            <i class="iconfont icon-github"></i>
        </a>
    
        <a href="https://www.qq.com/" title="QQ" rel="nofollow" target="_blank">
            <i class="iconfont icon-QQ"></i>
        </a>
    
        <a href="https://wx.qq.com/" title="WeChat" rel="nofollow" target="_blank">
            <i class="iconfont icon-weixin"></i>
        </a>
    
</div>

<!-- sidebar social end -->
                <!-- info -->
<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<ul class="trm-table trm-mb-20">
    
        <li>
            <div class="trm-label">
                地址:
            </div>
            <div class="trm-label trm-label-light">
                重庆 渝北 西唯兵
            </div>
        </li>
    
        <li>
            <div class="trm-label">
                年龄:
            </div>
            <div class="trm-label trm-label-light">
                20
            </div>
        </li>
    
</ul>
<!-- info end -->

                
    <div class="trm-divider trm-mb-40 trm-mt-40"></div>
    <!-- action button -->
    <div class="text-center">
        <a href="mailto:1687723655@qq.com" class="trm-btn">
            联系我
            <i class="iconfont far fa-envelope"></i>
        </a>
    </div>
    <!-- action button end -->

            </div>
            <div name="tabs-toc" class="trm-tabs-item active">
                <div class="post-toc">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">泛型机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.1.</span> <span class="toc-text">为什么会有泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.2.</span> <span class="toc-text">泛型基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.2.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.3.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.4.</span> <span class="toc-text">泛型数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.3.</span> <span class="toc-text">泛型上下限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.4.</span> <span class="toc-text">泛型的一些其他知识</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">注解机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.1.</span> <span class="toc-text">内置注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.2.</span> <span class="toc-text">注解的应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">异常机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">反射机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">SPI机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.0.1.</span> <span class="toc-text">实现SPI机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.0.2.</span> <span class="toc-text">使用SPI机制的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.0.3.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.0.4.</span> <span class="toc-text">如何获取SPI实现</span></a></li></ol></li></ol></li></ol>
</div>
            </div>
        </div>
    
    </div>
</div>
                    <!-- main card end -->
                </div>
            
            <div id="page-content" class="col-lg-8">
                <div class="trm-content" id="trm-content">
                    <div data-scroll data-scroll-repeat data-scroll-offset="500" id="about-triger"></div>

                    <div id="post-info" class="row hidden-sm">
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-calendar-alt trm-icon"></i><br>
            04/14
        </div>
    </div>
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-clock trm-icon"></i><br>
            09:50
        </div>
    </div>
    <div class="col-sm-4">
        <div id="post-author" class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-user trm-icon"></i><br>
            Deep Octopus
        </div>
    </div>
</div>
<div class="trm-card ">
    <article id="article-container" class="trm-publication">
    <h1><span id="泛型机制">泛型机制</span></h1>
<h2><span id="为什么会有泛型">为什么会有泛型</span></h2>
<p>​		为了实现参数化类型的控制，引入了泛型。泛型能够使得不同的类型在执行相同的代码时得到重复利用（代码复用）。泛型可以用在类、接口和方法中，分别称为泛型类、泛型接口和泛型方法。通过一个例子来解释，以多个加法方法为例，如果没有泛型，我们需要为每种类型都写一个加法方法。但是，通过泛型，我们可以使用一个加法方法实现多种数据类型的加法。</p>
<p>下面是一个使用泛型的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">		System.out.println(a + “+” + b + “=” + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">		<span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在这个示例中，泛型的类型在实际使用时进行指定，从而避免了需要进行强制类型转换的问题，同时由于编译期进行类型检查，也可以保证程序的类型安全。</p>
<p>​		以一个List集合为例，如果不使用泛型，其中的元素类型不受约束，需要开发者手动进行类型转换，从而容易引发ClassCastException异常。但是，使用泛型后，集合中仅允许存储指定类型的元素，可以在编译前自动检查类型，确保类型安全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>list中只能放String, 不能放其它类型的元素</p>
</blockquote>
<h2><span id="泛型基本使用">泛型基本使用</span></h2>
<p>当你编写一些通用代码时，你可能想要编写可以适用于多种不同类型的数据的函数或类。泛型是一种编程技术，它允许你编写这样的代码。</p>
<p>在大多数编程语言中，泛型使用尖括号来指定类型参数。例如，在Java中，你可以编写一个泛型类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T myField;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getMyField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> myField;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMyField</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        myField = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>&lt;T&gt;</code>表示这是一个泛型类，<code>T</code>是类型参数的名称。这个类有一个<code>myField</code>属性，类型为<code>T</code>，并且有一个可以设置和获取这个属性的方法。</p>
<p>你可以创建一个<code>MyGenericClass</code>对象，并指定类型参数的实际类型，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyGenericClass&lt;String&gt; myString = <span class="keyword">new</span> <span class="title class_">MyGenericClass</span>&lt;String&gt;();</span><br><span class="line">myString.setMyField(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> myString.getMyField(); <span class="comment">// value is &quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>&lt;String&gt;</code>指定了<code>MyGenericClass</code>的类型参数为<code>String</code>，因此你可以在<code>myField</code>中存储字符串，并使用<code>getMyField</code>方法来获取它。</p>
<p>泛型主要有泛型类、泛型方法、泛型接口、泛型数组几种最为常见的用法</p>
<h3><span id="泛型类">泛型类</span></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>简单的泛型</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T contents;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContents</span><span class="params">(T contents)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.contents = contents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getContents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> contents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中，我们定义了一个Box类，它只包含一个泛型类型T。Box类有两个方法：setContents和getContents，它们分别用于设置和获取Box对象的内容。这个内容的类型为T，也就是泛型类型参数。</p>
<p>使用Box类时，可以指定泛型类型参数的具体类型。例如，下面的代码创建了两个Box对象，它们的泛型类型分别为String和Integer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;String&gt; boxOfStrings = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">boxOfStrings.setContents(<span class="string">&quot;Hello, Generic Types!&quot;</span>);</span><br><span class="line"></span><br><span class="line">Box&lt;Integer&gt; boxOfIntegers = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">boxOfIntegers.setContents(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>可以通过调用getContents方法来获取Box对象的内容，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">contentsString</span> <span class="operator">=</span> boxOfStrings.getContents();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">contentsInteger</span> <span class="operator">=</span> boxOfIntegers.getContents();</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>多元泛型</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Entry&lt;K, V&gt;&gt; entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Map</span><span class="params">()</span> &#123;</span><br><span class="line">        entries = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        entries.add(<span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : entries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey().equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Entry</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中，我们定义了一个Map类，使用K和V表示泛型类型。类内部使用List来存储键值对，其中键类型为K，值类型为V。put方法将一个键值对添加到Map中，get方法则根据指定的键返回相应的值。此外，Map类内部还定义了一个Entry类，用来表示键值对。</p>
<h3><span id="泛型方法">泛型方法</span></h3>
<p>泛型方法，是在调用方法的时候指明泛型的具体类型。重点看下泛型的方法（图参考自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html%EF%BC%89">https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html）</a></p>
<p><img src="/images/2023-04-14-Java%E4%BA%94%E5%A4%A7%E6%9C%BA%E5%88%B6/java-basic-generic-4.png" alt="img" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>下面是一个简单的Java泛型方法的示例，它用于判断一个元素是否存在于一个数组中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(T[] array, T element)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (T item : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.equals(element)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中，我们声明了一个泛型方法contains，它接受一个泛型类型为T的数组array和一个泛型类型为T的元素element作为参数，并返回一个boolean值，表示数组中是否存在该元素。</p>
<p>在方法实现中，我们使用了for-each循环遍历数组中的每一个元素，然后使用equals方法判断该元素是否与指定元素相等。由于在声明泛型方法时没有使用 extends 关键字来限制泛型类型参数，因此该方法适用于任何类型的数组和元素。</p>
<p>可以通过以下代码来使用该泛型方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] array1 = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;&#125;;</span><br><span class="line">boolean result1 = Utils.contains(array1, &quot;banana&quot;);  // 返回true</span><br><span class="line"></span><br><span class="line">Integer[] array2 = &#123;1, 2, 3&#125;;</span><br><span class="line">boolean result2 = Utils.contains(array2, 4);  // 返回false</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们分别用一个字符串数组和一个整数数组来调用contains方法，检查指定元素是否存在于数组中。由于在方法实现中使用了泛型，因此可以处理不同类型的数组和元素。</p>
<p>下面是一个复杂一点的Java泛型方法的示例，用于比较两个对象的大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.compareTo(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们声明了一个泛型方法compare，它接受两个泛型类型相同的参数a和b，并返回它们之间的比较结果。这里使用了 extends 关键字限制泛型类型参数为 Comparable 接口的子类型，即要求 T 必须能够进行比较。</p>
<p>使用泛型方法时，编译器会根据实际参数的类型自动推断出泛型类型参数的具体类型，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> Utils.compare(<span class="number">1</span>, <span class="number">2</span>);          <span class="comment">// 返回-1，即1 &lt; 2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> Utils.compare(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);  <span class="comment">// 返回负数，即&quot;hello&quot; &lt; &quot;world&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们分别比较了两个整数和两个字符串的大小。由于整数和字符串都实现了 Comparable 接口，所以它们可以作为泛型类型参数传递给compare方法。</p>
<h3><span id="泛型接口">泛型接口</span></h3>
<p>下面是一个简单的Java泛型接口的示例，它定义了一个通用的栈（stack）接口，其中的元素可以是任何类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stack</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T element)</span>;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个Stack接口，使用泛型类型T表示栈中元素的类型。接口中定义了三个方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>push方法：将一个元素压入栈中；</p>
</li>
<li class="lvl-2">
<p>pop方法：从栈中弹出一个元素，并返回该元素；</p>
</li>
<li class="lvl-2">
<p>isEmpty方法：判断栈是否为空。</p>
</li>
</ul>
<p>由于在声明接口时使用了泛型类型参数，因此实现该接口的类可以针对不同的类型进行栈的操作。</p>
<p>例如，可以定义一个String类型的栈：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringStack</span> <span class="keyword">implements</span> <span class="title class_">Stack</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringStack</span><span class="params">()</span> &#123;</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(String element)</span> &#123;</span><br><span class="line">        elements.add(<span class="number">0</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elements.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elements.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们实现了一个String类型的栈StringStack，它针对字符串类型进行栈的操作。在类定义中使用了implements关键字来表示实现了Stack接口，并且在声明时使用了具体的泛型类型参数String。然后，定义了三个方法来实现Stack接口中定义的方法。</p>
<p>可以使用以下代码来对该栈进行操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringStack</span>();</span><br><span class="line">stack.push(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">    System.out.println(stack.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们创建一个StringStack对象，并使用push方法将两个字符串压入栈中。然后使用while循环依次弹出栈中的元素，并将它们输出到控制台。由于在定义StringStack类时指定了泛型类型参数String，因此该类只能处理字符串类型的元素。如果想要处理其他类型的元素，可以定义其他类型的栈类并实现Stack接口。</p>
<h3><span id="泛型数组">泛型数组</span></h3>
<p>Java 中的泛型数组有些限制，无法用具体类型参数直接创建泛型数组。一种常见的解决方案是定义一个类型为 Object 的数组，并将其转换为泛型数组。下面是一个简单的Java泛型数组的示例，演示了如何创建一个指定类型的泛型数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] createArray(<span class="type">int</span> length, T sample) &#123;</span><br><span class="line">        T[] array = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            array[i] = sample;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个泛型方法 createArray，它接受两个参数：一个整数length，表示数组的长度；一个泛型类型参数sample，表示数组中的元素类型和默认值。在方法实现中，我们首先创建了一个类型为 Object 的数组，然后将其转换为泛型类型数组。</p>
<p>使用泛型数组时，可以通过传递一个示例元素来确定元素的具体类型。例如，可以使用以下代码创建一个字符串类型的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = ArrayUtils.createArray(<span class="number">5</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 createArray 方法来生成一个长度为 5 的字符串类型的数组，其初始值均为 “”。</p>
<p>需要注意的是，Java 中的泛型数组存在与类型擦除相关的限制，具体实现时需要考虑到类型安全和性能问题。在实际应用中，需要权衡使用泛型数组和其他数据结构的优缺点。</p>
<h2><span id="泛型上下限">泛型上下限</span></h2>
<p>Java中的泛型上限（Upper Bound）和下限（Lower Bound）指的是限制泛型参数类型的范围，可以用在泛型方法、泛型接口、泛型类等多种场景中。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>上限（Upper Bound）：使用 extends 关键字，表示泛型参数必须是指定类型或者其子类型。例如，&lt;? extends Number&gt; 表示泛型参数必须是 Number 类型或其子类的类型。</p>
<ul class="lvl-2">
<li class="lvl-6">数组 <code>T[]</code> 是一个特殊的类型，它没有上限，也就是说，不能声明为 <code>T extends E[]</code> 的形式。如果需要声明一个可以包含数组元素的泛型类或者泛型方法，可以将其定义为 <code>T[]</code> 类型。</li>
</ul>
</li>
<li class="lvl-2">
<p>下限（Lower Bound）：使用 super 关键字，表示泛型参数必须是指定类型或者其父类型。例如，&lt;? super Integer&gt; 表示泛型参数必须是 Integer 类型或其父类的类型。</p>
</li>
</ul>
<p>下面是一个简单的示例，演示了上限和下限的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(T[] array)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i].compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addNumbers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了两个示例方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>max方法：接受一个泛型类型为T的数组，使用 extends 关键字来限定泛型参数类型必须是Comparable接口的子类。该方法返回数组中最大的元素。</p>
</li>
<li class="lvl-2">
<p>addNumbers方法：接受一个泛型类型为List&lt;? super Integer&gt;的参数，使用 super 关键字限制泛型参数类型必须是Integer类型或其父类。该方法用于向列表中添加数字。</p>
</li>
</ul>
<p>可以使用以下代码来调用这些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">String[] strings = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Max integer: &quot;</span> + BoundExample.max(integers)); <span class="comment">// 输出：Max integer: 5</span></span><br><span class="line"><span class="comment">// 下行中不能将`strs`传给`max`方法, 因为泛型参数必须是 Comparable&lt;T&gt; 的子类型</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;Max string: &quot; + BoundExample.max(strings));</span></span><br><span class="line"></span><br><span class="line">List&lt;Number&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">BoundExample.addNumbers(numbers);</span><br><span class="line">System.out.println(<span class="string">&quot;Numbers: &quot;</span> + numbers); <span class="comment">// 输出：Numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们分别使用 Integer 和 String 类型的数组来调用 max 方法，说明了使用 extends 关键字时的限制。在调用 addNumbers 方法时，我们使用了 List<number> 类型的参数，演示了使用 super 关键字时的限制。</number></p>
<h2><span id="泛型的一些其他知识">泛型的一些其他知识</span></h2>
<ol>
<li class="lvl-3">
<p>泛型的类型擦除</p>
</li>
</ol>
<p>Java 中的泛型本身并不是一种运行时的机制，它仅仅是一种编译时的类型检查机制。在 Java 代码被编译成字节码后，泛型信息被擦除了，也就是说，编译器在编译时会自动将泛型转换为相应的较低类型，比如 Object 类型。例如，一个<code>List&lt;Integer&gt;</code>在运行时会成为一个<code>List</code>类型。</p>
<p>由于类型擦除的存在，有时候在泛型类和泛型方法中，我们并不能直接获取到泛型类型的具体信息。为了解决这个问题，可以使用反射机制来获取泛型类型的信息。</p>
<ol start="2">
<li class="lvl-3">
<p>关于类型通配符</p>
</li>
</ol>
<p>在 Java 中，我们使用通配符（wildcard）来表示通用类型，通配符可以用来声明泛型的上限和下限。有三种使用通配符的方式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>&lt;?&gt;</code>：表示未知类型，相当于不限定泛型类型；</p>
</li>
<li class="lvl-2">
<p><code>&lt;? extends T&gt;</code>：表示泛型类型必须是T类型或其子类类型；</p>
</li>
<li class="lvl-2">
<p><code>&lt;? super T&gt;</code>：表示泛型类型必须是T类型或其父类类型。</p>
</li>
</ul>
<p>需要注意的是，类型通配符是一种泛型限制，只能使用在参数中，不能用于类、方法的定义上。</p>
<ol start="3">
<li class="lvl-3">
<p>泛型和继承的关系</p>
</li>
</ol>
<p>泛型和继承都是 Java 中的重要特性，它们之间有着紧密的联系。Java 中的泛型可以用来实现多态，而继承则是 Java 中的一种多态机制。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>父类的泛型可以传递给子类：如果一个类使用了泛型，那么它的子类可以继承它，并且子类也可以使用泛型，这样就可以实现泛型的传递。例如，<code>List&lt;String&gt;</code>是<code>List&lt;?&gt;</code>的子类型。</p>
</li>
<li class="lvl-2">
<p>泛型类型不能区分父类与子类：Java 中的泛型是通过类型擦除来实现的，因此在泛型类或方法的继承关系中，子类不能区分父类与子类的类型。</p>
</li>
</ul>
<ol start="4">
<li class="lvl-3">
<p>泛型和数组的区别</p>
</li>
</ol>
<p>Java 的泛型和数组有些相似，但也有不同之处：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>泛型与数组都能够对元素进行类型检查，并提供相关的方法和操作；</p>
</li>
<li class="lvl-2">
<p>与数组不同，泛型不能直接创建具体的类型，只能创建通用类型；</p>
</li>
<li class="lvl-2">
<p>与泛型不同，数组可以定义具体类型的多维数组，而泛型无法直接实现多维泛型数组。</p>
</li>
</ul>
<p>需要注意的是，Java 中的泛型是在编译时进行类型擦除的，而数组则是在运行时进行类型检查的。因此，在使用泛型和数组时，需要根据具体的情况进行选择。</p>
<ol start="5">
<li class="lvl-3">
<p>泛型和反射的结合应用</p>
</li>
</ol>
<p>Java 中的泛型和反射是两个非常强大的特性，在实际应用时可以结合使用，实现更高级、更灵活的编程技巧。例如：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用反射获取泛型类型信息：由于泛型的类型信息在编译时被擦除了，因此我们可以使用反射机制来获取泛型类型的信息，包括类、方法、字段等级别的泛型类型信息。使用反射的泛型信息可以在运行时做到更加灵活和高效地处理对象和数据。</p>
</li>
<li class="lvl-2">
<p>通过反射操作泛型数组：Java 中的泛型数组有一些限制，不能用具体类型参数数组直接创建泛型数组。但是通过反射，我们可以使用 Java 提供的 Array 类来创建特定的泛型数组，并进行相关的操作。</p>
</li>
</ul>
<p>下面是一个使用反射操作泛型数组的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericArray</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericArray</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">        array = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, T item)</span> &#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenericArray&lt;String&gt; ga = <span class="keyword">new</span> <span class="title class_">GenericArray</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用反射设置元素</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> ga.getClass().getMethod(<span class="string">&quot;set&quot;</span>, <span class="type">int</span>.class, Object.class);</span><br><span class="line">            m.invoke(ga, <span class="number">0</span>, <span class="string">&quot;Hello, Generic Array!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取一个Object[]数组</span></span><br><span class="line">        Object[] objects = ga.getArray();</span><br><span class="line">        objects[<span class="number">1</span>] = <span class="number">123</span>; <span class="comment">// 运行时错误：ArrayStoreException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个泛型类 GenericArray，并使用反射来操作它的元素，并演示了泛型数组的限制。</p>
<p>需要注意的是，泛型数组在 Java 中有其局限性，因此在实际使用时需要谨慎开发。</p>
<ol start="6">
<li class="lvl-3">
<p>泛型与静态方法和静态属性</p>
</li>
</ol>
<p>Java泛型不能用在静态方法或静态属性上面，是因为泛型类型的擦除机制在这种情况下会导致类型信息的丢失。由于静态方法和静态属性是属于类本身的，不属于类的实例，因此在使用泛型时，它们并没有明确的实例化对象来指定类型。这就导致在编译时，JVM无法确定泛型类型的具体信息，只能使用Object类型来代替，而这样会导致编译错误或者运行时类型错误的出现。</p>
<p>例如，我们考虑下面这个不合法的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        Test.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个静态变量value和两个静态方法setValue和getValue，其中value的类型参数为T。由于静态变量和静态方法是属于类本身的，而非类的实例，因此在静态方法中并不能访问泛型的类型参数T。这就会导致编译时出现错误，提示无法引用非静态变量T。</p>
<p>虽然Java中不能直接在静态方法或静态属性上使用泛型，但可以通过传递类类型做为参数，实现在静态方法中使用泛型的目的。例如，可以将类型参数传递给静态方法，或将类型参数传递给泛型类的构造函数来实现泛型的静态方法或属性使用。</p>
<ol start="7">
<li class="lvl-3">
<p>异常与泛型</p>
</li>
</ol>
<p>Java中的异常处理机制允许我们在throw和catch语句中使用泛型，从而实现异常信息的类型安全和灵活性。Java的异常层次结构中定义了一些通用的异常类，例如Exception、RuntimeException、Error等，这些异常类能够用于处理不同类型的异常情况。使用泛型可以使异常处理更加具有通用性、灵活性和类型安全性。</p>
<p>Java泛型与异常处理通常需要结合在一起使用，其主要使用方式包括以下几点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用泛型来定义异常类</p>
</li>
</ul>
<p>在Java中，可以使用泛型来定义异常类，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> T detail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(T detail)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.detail = detail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getDetail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> detail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个泛型异常类MyException，它继承了Exception类。在MyException类中，我们定义了一个泛型变量detail，用于存储异常的详细信息。使用泛型定义异常类，可以使得异常类的使用更加的通用和灵活。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>抛出泛型异常</p>
</li>
</ul>
<p>在Java中，我们可以使用throw关键字来抛出一个异常，如果该异常是一个泛型异常，我们也需要使用泛型类型传递异常信息，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> <span class="keyword">throws</span> MyException&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>&lt;&gt;(<span class="string">&quot;An error occurred&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用MyException泛型异常类抛出了一个异常，并使用泛型类型String传递了异常信息。这样可以使得异常信息更具有类型安全性。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>捕获泛型异常</p>
</li>
</ul>
<p>在Java中，我们可以使用catch关键字来捕获一个异常，如果该异常是一个泛型异常，我们也需要使用泛型类型对异常进行捕获，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Some code that may throw an exception</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (MyException&lt;String&gt; ex) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Error: &quot;</span> + ex.getDetail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们捕获了一个MyException类型的泛型异常，并使用泛型类型String来处理异常信息。这样可以使得异常处理更加类型安全和灵活。</p>
<p>总之，Java中的异常处理机制允许我们使用泛型来实现更具类型安全和灵活性的异常处理。通过使用泛型，可以让异常处理更加通用和灵活，同时防止出现类型错误，使程序更加健壮和安全。</p>
<ol start="8">
<li class="lvl-3">
<p>获取java泛型的参数类型</p>
</li>
</ol>
<p>在Java中，我们可以使用反射机制获取泛型参数的类型。Java泛型在编译时会进行类型擦除，将泛型类型的所有参数都替换成它们的上界类型或Object类型，这可能会导致实例化时无法获取泛型的具体类型。但是，在通过反射机制访问类的内容时，可以获取泛型的类型参数。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>原生反射</p>
<p><code>java.lang.reflect.Type</code>是Java中所有类型的公共高级接口, 代表了Java中的所有类型. Type体系中类型的包括：数组类型(GenericArrayType)、参数化类型(ParameterizedType)、类型变量(TypeVariable)、通配符类型(WildcardType)、原始类型(Class)、基本类型(Class), 以上这些类型都实现Type接口。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericType</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenericType&lt;String&gt; genericType = <span class="keyword">new</span> <span class="title class_">GenericType</span>&lt;String&gt;() &#123;&#125;;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">superclass</span> <span class="operator">=</span> genericType.getClass().getGenericSuperclass();</span><br><span class="line">        <span class="comment">//getActualTypeArguments 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> ((ParameterizedType) superclass).getActualTypeArguments()[<span class="number">0</span>]; </span><br><span class="line">        System.out.println(type);<span class="comment">//class java.lang.String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>ParameterizedType</code>:</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ParameterizedType</span> <span class="keyword">extends</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="comment">// 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span></span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回当前class或interface声明的类型, 如List&lt;?&gt;返回List</span></span><br><span class="line">    Type <span class="title function_">getRawType</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回所属类型. 如,当前类型为O&lt;T&gt;.I&lt;S&gt;, 则返回O&lt;T&gt;. 顶级类型将返回null </span></span><br><span class="line">    Type <span class="title function_">getOwnerType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>参考链接：<a target="_blank" rel="noopener" href="https://pdai.tech/md/java/basic/java-basic-x-generic.html">https://pdai.tech/md/java/basic/java-basic-x-generic.html</a></p>
</li>
</ul>
<p>还可以使用TypeToken和TypeReference两种方式获取泛型参数的类型，这两种方式都是通过创建带泛型参数的子类并提取类型信息来实现的。以下是两种方式的介绍及代码示例：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>TypeToken方式获取泛型参数的类型</p>
</li>
</ul>
<p>TypeToken是Gson库中的一个类，可以用来获取泛型的类型信息。可以通过继承TypeToken类来获取泛型参数的类型信息，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTypeToken</span> <span class="keyword">extends</span> <span class="title class_">TypeToken</span>&lt;MyGenericType&lt;String&gt;&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTypeToken</span>().getType();</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个MyTypeToken类，它继承了TypeToken&lt;MyGenericType<string>&gt;类，其中MyGenericType是一个泛型类，String是它的类型参数。通过调用getType方法可以获取泛型的类型参数。</string></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>TypeReference方式获取泛型参数的类型</p>
</li>
</ul>
<p>TypeReference是jackson库中的一个类，也可以用来获取泛型参数的类型信息。与TypeToken类似，可以通过继承TypeReference类来获取泛型参数的类型信息，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MyTypeReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">TypeReference</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTypeReference</span>&lt;MyGenericType&lt;String&gt;&gt;()&#123;&#125;.getType();</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个抽象类MyTypeReference，它继承了TypeReference&lt;MyGenericType<string>&gt;类。通过在MyTypeReference类中加入类型参数T并对其进行继承，就可以获取泛型的类型参数。</string></p>
<p>总之，通过使用TypeToken和TypeReference等方式可以获取Java泛型的参数类型，使得泛型类型更具有灵活性和通用性。这些方式可以通过创建带泛型参数的子类获取泛型类型信息，使得泛型的使用更加灵活和类型安全。</p>
<h1><span id="注解机制">注解机制</span></h1>
<blockquote>
<p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它是框架学习和设计者必须掌握的基础。</p>
</blockquote>
<h2><span id="内置注解">内置注解</span></h2>
<p>Java内置了许多注解，其中一些常见的注解包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>@Override：用于表示一个方法是覆盖了父类的方法。</p>
</li>
<li class="lvl-2">
<p>@Deprecated：用于标记一个类、方法或字段已经过时，建议不再使用。</p>
</li>
<li class="lvl-2">
<p>@SuppressWarnings：用于抑制编译器警告，可以用来禁止特定的警告或全部警告。</p>
</li>
</ul>
<p>以下是这些常见内置注解的具体用法示例：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>@Override：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moving</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Moving...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tiger</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moving</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>Tiger</code>类覆盖了<code>Animal</code>类的<code>moving()</code>方法，并使用了<code>@Override</code>注解来表示它们的关系，这样做在代码审查时可以更容易地发现代码中的错误。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>@Deprecated：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>getName()</code>方法被标记为不推荐使用。在实际应用中，如果开发人员使用了<code>getName()</code>方法，开发工具将弹出一个警告窗口，提醒开发人员该方法已被弃用，需要使用其他替代方法。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>@SuppressWarnings：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(Collection books)</span> &#123;</span><br><span class="line">        books.add(<span class="keyword">new</span> <span class="title class_">Book</span>()); <span class="comment">// 这里会出现“未经检查的类型转换”警告</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>addAll()</code>方法将一个<code>Collection</code>对象作为参数，并使用了<code>@SuppressWarnings(&quot;unchecked&quot;)</code>注解来抑制Java编译器产生的“未经检查的类型转换”警告。由于Java的类型擦除机制，<code>Collection</code>对象的类型在运行时是不可知的，因此需要使用注解来提示编译器这是有意为之的。</p>
<p>##元注解</p>
<p>元注解是用于注解其他注解的注解。Java中的元注解包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>@Target：指定注解可以用在哪些地方，如类、方法、字段等。</p>
</li>
<li class="lvl-2">
<p>@Retention：指定注解保留的时间，可以是编译时、运行时或者源代码中。</p>
</li>
<li class="lvl-2">
<p>@Documented：指定注解会被包含在Java文档中。</p>
</li>
<li class="lvl-2">
<p>@Inherited：指定注解可以被子类继承。</p>
</li>
<li class="lvl-2">
<p>@Repeatable：指定注解可以重复使用（Java8之后引入）。</p>
</li>
<li class="lvl-2">
<p>@Native：指定本地方法的签名（Java8之后引入）。</p>
</li>
</ul>
<p>以下是元注解的具体使用示例：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>@Target：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// some code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>@MyAnnotation</code>注解只能用于方法上。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>@Retention：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// some code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>@MyAnnotation</code>注解会被保留到运行时。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>@Documented：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// some code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>@MyAnnotation</code>注解会被包含在Java文档中。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>@Inherited：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// some code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>@MyAnnotation</code>注解可以被子类继承。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>@Repeatable：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(MyAnnos.class)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="comment">// some code here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> MyAnnos &#123;</span><br><span class="line">    MyAnno[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>@MyAnno</code>注解可以多次使用，并使用<code>@MyAnnos</code>来包装它们。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>@Native：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLibrary</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>; <span class="comment">// method signature is declared as native</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>fun()</code>方法是一个本地方法，其方法签名被声明为<code>native</code>。这样编译器就会知道在编译期间需要为该方法生成本地代码。</p>
<p>##自定义注解</p>
<p>除了内置注解之外，Java还支持自定义注解。自定义注解可以用于标记代码中的特定元素，例如类、方法、变量等，以实现各种功能，如配置、文档生成、代码分析等。自定义注解可以使用Java反射机制来访问和处理。</p>
<p>以下是一个简单的Java自定义注解的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span>[] numbers() <span class="keyword">default</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们使用了<code>@interface</code>来定义自己的注解，注解名字为<code>MyAnnotation</code>，注解内容包括一个<code>String</code>类型的属性<code>value</code>和一个整型数组类型的属性<code>numbers</code>。<code>@Retention</code>注解指定该注解在运行时保留，<code>@Target</code>注解指定该注解只能用于方法上。在使用<code>MyAnnotation</code>时，我们可以通过<code>value</code>属性设置该注解的值，在使用<code>numbers</code>属性时，我们可以通过赋值来给数组赋初值。以下是一个使用该自定义注解的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;Hello, world!&quot;, numbers = &#123;1, 2, 3, 4&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们在<code>doSomething()</code>方法上应用了自定义注解<code>@MyAnnotation</code>，并设置了<code>value</code>和<code>numbers</code>属性的值。在实际应用中，我们可以通过反射机制来获取注解信息，并据此进行一些特定的操作，例如根据注解的值来判断是否执行某个方法，或者根据注解的信息来生成代码等。</p>
<p>##Java8新的注解</p>
<p>Java8引入了一些新的注解，包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>@FunctionalInterface：用于标记一个接口是函数式接口，即只包含一个抽象方法的接口。</p>
</li>
<li class="lvl-2">
<p>@Repeatable：用于标记一个注解可以重复使用。</p>
</li>
<li class="lvl-2">
<p>@SafeVarargs：用于标记一个方法使用了可变参数，并且不会出现类型安全问题。</p>
</li>
<li class="lvl-2">
<p>@FunctionalInterface：用于标记一个接口是函数式接口，即只包含一个抽象方法的接口。</p>
</li>
<li class="lvl-2">
<p>@Repeatable：用于标记一个注解可以重复使用。</p>
</li>
</ul>
<ol start="5">
<li class="lvl-3">
<p>注解的应用场景</p>
</li>
</ol>
<p>Java注解的应用场景很广泛，常见的应用场景包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>配置信息：例如Spring框架中的@Value注解，用于指定属性的值。</p>
</li>
<li class="lvl-2">
<p>文档生成：例如JavaDoc注解，用于生成Java文档。</p>
</li>
<li class="lvl-2">
<p>代码分析：例如JUnit框架中的@Test注解，用于标记测试方法。</p>
</li>
<li class="lvl-2">
<p>依赖注入：例如Spring框架中的@Autowired注解，用于自动注入依赖对象。</p>
</li>
<li class="lvl-2">
<p>AOP：例如Spring框架中的@Aspect注解，用于声明切面。</p>
</li>
</ul>
<p>##配置化到注解化 - 框架的演进</p>
<p>随着软件开发的不断演进，从传统的配置文件到注解配置的转变成为趋势。例如Spring框架最初使用XML配置，但随着注解的发展，现在Spring框架可以通过注解配置。这种配置方式更加直观和简洁，也更容易维护。除了Spring框架之外，许多现代化的框架都支持使用注解进行配置，例如Hibernate、MyBatis、Struts2等。</p>
<p>##自定义注解和AOP</p>
<p>自定义注解和AOP（面向切面编程）相结合，可以实现更加灵活和高效的编程。通过定义切点和切面，可以在代码中对特定的方法或类进行切入，从而实现各种功能，如事务管理、日志记录、性能监控等。</p>
<p>##注解支持继承吗？</p>
<p>Java注解支持继承，子类可以继承父类的注解。如果一个注解被@Inherited修饰，那么它可以被子类继承。如果一个注解没有被@Inherited修饰，那么它不能被子类继承。</p>
<p>以下是一个Java注解的继承案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@interface</span> ParentAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@interface</span> ChildAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ParentAnnotation(value = &quot;Parent Annotation&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ChildAnnotation(value = &quot;Child Annotation&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们定义了两个注解: <code>ParentAnnotation</code>和<code>ChildAnnotation</code> 。 <code>Parent</code>类使用<code>ParentAnnotation</code>注解进行标记， <code>Child</code>继承了<code>Parent</code>，并使用了<code>ChildAnnotation</code>注解。我们还对<code>ParentAnnotation</code>注解用<code>@Inherited</code>进行修饰，使得这个注解可以从父类继承到子类。</p>
<p>我们可以通过以下代码来获取类的注解信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;Child&gt; childClass = Child.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">ParentAnnotation</span> <span class="variable">parentAnnotation</span> <span class="operator">=</span> childClass.getAnnotation(ParentAnnotation.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;ParentAnnotation: &quot;</span> + parentAnnotation);</span><br><span class="line"></span><br><span class="line">        <span class="type">ChildAnnotation</span> <span class="variable">childAnnotation</span> <span class="operator">=</span> childClass.getAnnotation(ChildAnnotation.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;ChildAnnotation: &quot;</span> + childAnnotation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们通过<code>getAnnotation()</code>方法分别获取了<code>Child</code>和<code>Parent</code>的注解信息。由于<code>ParentAnnotation</code>被标记为<code>@Inherited</code>，因此<code>ParentAnnotation</code>的信息会被<code>Child</code>类所继承 , 上述代码会输出以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ParentAnnotation: <span class="meta">@ParentAnnotation(value=Parent Annotation)</span></span><br><span class="line">ChildAnnotation: <span class="meta">@ChildAnnotation(value=Child Annotation)</span></span><br></pre></td></tr></table></figure>
<p>从输出可以看到，<code>Child</code>类成功继承了<code>ParentAnnotation</code>注解。</p>
<p>##注解实现的原理</p>
<p>Java注解的实现原理是使用反射机制来访问和处理注解。当程序使用注解时，编译器会将注解信息保存到编译后的.class文件中。在运行时，使用反射机制可以访问.class文件中的注解信息，并进行相应的处理。</p>
<p>下面是一个具体的示例，将展示如何使用反射机制访问和处理Java注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;Hello, world!&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> myObj.getClass().getMethod(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">        <span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(MyAnnotation.class);</span><br><span class="line">        System.out.println(annotation.value()); <span class="comment">// 输出: &quot;Hello, world!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们定义了一个自定义的 <code>MyAnnotation</code>注解以及一个 <code>MyClass</code>类，其中 <code>doSomething()</code> 方法被标记了 <code>@MyAnnotation</code> 注解。</p>
<p>在 <code>Test</code> 类的 <code>main()</code> 方法中，首先创建了 <code>MyClass</code> 的实例 <code>myObj</code>，然后使用反射机制获取了 <code>doSomething()</code> 方法的引用对象 <code>Method</code>。接着，通过 <code>Method</code> 的 <code>getAnnotation()</code> 方法读取了 <code>doSomething()</code> 方法标记的 <code>@MyAnnotation</code> 注解，并将注解信息存储在 <code>annotation</code> 变量中。</p>
<p>最后，通过打印输出 <code>annotation.value()</code>，成功地将注解的值 “Hello, world!” 输出到了控制台。</p>
<p>从上述分析中，我们可以看出，Java 注解的实现原理就是在编译器将注解信息保存到字节码文件中，并通过反射机制在运行时读取和处理注解信息。这种机制使开发者可以通过非常简单的语法来给代码添加元数据，从而在运行时得到更多的程序信息，进而实现更加灵活和高效的编程。</p>
<p>##Java8提供了哪些新的注解？</p>
<p>Java8提供了一些新的注解，例如：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>@Repeatable：可以用于声明一个注解可以重复使用多次。</p>
</li>
<li class="lvl-2">
<p>@Native：可以用于声明一个本地方法（Native Method）。</p>
</li>
<li class="lvl-2">
<p>@FunctionalInterface：可以用于声明一个函数式接口。</p>
</li>
<li class="lvl-2">
<p>@SafeVarargs：可以用于声明一个方法使用可变参数，但是不会产生类型安全问题。</p>
</li>
<li class="lvl-2">
<p>@Deprecated：可以用于声明一个方法或类已经被弃用。</p>
</li>
<li class="lvl-2">
<p>@FunctionalInterface：可以用于声明一个函数式接口。</p>
</li>
</ul>
<h2><span id="注解的应用场景">注解的应用场景</span></h2>
<p>Java注解的应用场景非常广泛，可以用于各种领域和用途，例如：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>配置文件：可以用注解代替XML或属性文件进行配置。</p>
</li>
<li class="lvl-2">
<p>代码分析：可以用注解标记代码中的特定元素，如不安全的方法、过时的方法等。</p>
</li>
<li class="lvl-2">
<p>依赖注入：可以用注解注入对象或属性，如Spring框架的@Autowired注解。</p>
</li>
<li class="lvl-2">
<p>日志记录：可以用注解标记需要记录日志的方法或类，如Log4j框架的@Log注解。</p>
</li>
<li class="lvl-2">
<p>AOP：可以用注解实现面向切面编程，如Spring框架的@Aspect注解。</p>
</li>
</ul>
<p>##配置化到注解化 - 框架的演进</p>
<p>在软件开发的不同阶段，从配置化到注解化的演进是非常明显的趋势。传统的配置文件方式，比如XML、属性文件等，存在很多弊端，如复杂、容易出错、难以维护等。而注解化的方式更加直观、简洁、灵活，使得代码更加易于阅读和维护。</p>
<p>随着框架的不断演进，从继承实现到注解实现，是一个非常明显的趋势。比如，JUnit3是通过继承TestCase类来实现单元测试的，而JUnit4则是通过注解来实现单元测试。这种方式不仅使得测试代码更加简洁、易读，还可以将测试代码和被测试代码分离，使得代码更加松耦合。</p>
<p>##自定义注解和AOP - 通过切面实现解耦</p>
<p>自定义注解和AOP结合起来，可以实现更加灵活、高效的编程方式。通过定义切点和切面，可以对特定的方法或类进行切入，从而实现各种功能，如事务管理、日志记录、性能监控等。这种方式可以将关注点从业务逻辑中分离出来，提高代码的可维护性和可扩展性。</p>
<p>##总结</p>
<p>Java注解是一种强大的元数据机制，可以用于标记和处理代码中的特定元素，如类、方法、变量等。Java注解可以通过反射机制来访问和处理，可以实现各种功能，如配置、文档生成、代码分析、依赖注入、AOP等。随着软件开发的不断演进，从传统的配置文件到注解配置的转变成为趋势，注解化的编程方式可以使代码更加简洁、灵活和高效。</p>
<h1><span id="异常机制">异常机制</span></h1>
<p>Java中的异常机制是指在程序运行时出现错误或异常情况时，程序可以通过抛出异常来通知调用者发生了异常，从而使得调用者有机会处理这个异常。异常机制可以保证程序的健壮性和可靠性。</p>
<p>##异常的层次结构</p>
<p>Java中的异常分为两大类：Error和Exception。Error表示系统级别的错误，一般由虚拟机自己处理，程序员无需干预；Exception则表示程序运行时的异常情况，需要程序员进行处理。Exception又分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions），前者必须在方法签名中声明，后者不需要声明。</p>
<p>首先，我们来看一下Error类异常的例子。Error表示系统级别的错误，一般由虚拟机自己处理，程序员无需干预。例如，OutOfMemoryError表示内存不足错误，通常无法通过代码来处理它。下面是一个简单的OutOfMemoryError的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutOfMemoryErrorExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[Integer.MAX_VALUE];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们创建了一个长度为<code>Integer.MAX_VALUE</code>的数组，这远远超过了Java虚拟机所能分配的最大内存，因此会抛出OutOfMemoryError异常。</p>
<p>接下来，我们来看一下Exception类异常的例子。Exception表示程序运行时的异常情况，需要程序员进行处理。Exception又分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions），前者必须在方法签名中声明，后者不需要声明。下面是一个简单的IOException的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOExceptionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">            System.out.println(line);</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;An error occurred: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们尝试读取一个文件并打印其中的一行。由于文件可能不存在或读取过程中发生错误，因此我们使用了try-catch语句来捕获可能抛出的IOException异常。如果出现了异常，我们会打印异常信息并继续执行程序。</p>
<p>最后，我们来看一下RuntimeException类异常的例子。RuntimeException是Exception的一个子类，表示程序运行时的异常情况，不需要在方法签名中声明。下面是一个简单的ArithmeticException的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticExceptionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b; <span class="comment">// 除以0会抛出ArithmeticException异常</span></span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;An error occurred: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们尝试将10除以0，这会抛出ArithmeticException异常。由于ArithmeticException是RuntimeException的子类，因此我们不需要在方法签名中声明它，但我们仍然可以使用try-catch语句来捕获它。</p>
<p>总之，Java中的异常分为两大类：Error和Exception。Error表示系统级别的错误，一般由虚拟机自己处理，程序员无需干预；Exception则表示程序运行时的异常情况，需要程序员进行处理。Exception又分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions），前者必须在方法签名中声明，后者不需要声明。</p>
<p>##异常基础</p>
<p>​		Java中的异常关键字包括throws、throw和try-catch。throws用于在方法签名中声明可能抛出的异常类型，throw用于手动抛出一个异常，try-catch用于捕获并处理异常。</p>
<p>​		首先，我们来看一下throws关键字的例子。throws用于在方法签名中声明可能抛出的异常类型。例如，我们定义了一个方法<code>readFile</code>，它可能会抛出IOException异常，我们可以在方法签名中使用throws关键字来声明这个异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOExceptionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> readFile(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">            System.out.println(content);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;An error occurred: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readFile</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filename));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在上面的代码中，我们定义了一个静态方法<code>readFile</code>，它接受一个文件名作为参数，并返回文件的第一行内容。由于读取文件时可能会发生IOException异常，因此我们在方法签名中使用throws关键字来声明这个异常。在调用<code>readFile</code>方法时，我们使用try-catch语句来捕获可能抛出的IOException异常。</p>
<p>​		接下来，我们来看一下throw关键字的例子。throw用于手动抛出一个异常。例如，我们定义了一个方法<code>divide</code>，它接受两个整数作为参数，并返回它们的商。如果除数为0，则无法计算，我们可以使用throw关键字手动抛出一个ArithmeticException异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticExceptionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> divide(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;An error occurred: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;Division by zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在上面的代码中，我们定义了一个静态方法<code>divide</code>，它接受两个整数作为参数，并返回它们的商。如果除数为0，则无法计算，我们使用throw关键字手动抛出一个ArithmeticException异常。在调用<code>divide</code>方法时，我们使用try-catch语句来捕获可能抛出的ArithmeticException异常。</p>
<p>​		最后，我们来看一下try-catch关键字的例子。try-catch用于捕获并处理异常。例如，我们定义了一个方法<code>readFile</code>，它接受一个文件名作为参数，并返回文件的第一行内容。如果读取文件时发生IOException异常，则返回空字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOExceptionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> readFile(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readFile</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filename));</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">            reader.close();</span><br><span class="line">            <span class="keyword">return</span> line;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;An error occurred: &quot;</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在上面的代码中，我们定义了一个静态方法<code>readFile</code>，它接受一个文件名作为参数，并返回文件的第一行内容。在方法中，我们使用try-catch语句来捕获可能抛出的IOException异常。如果发生异常，我们打印异常信息并返回空字符串。</p>
<p>​		总之，Java中的异常关键字包括throws、throw和try-catch。throws用于在方法签名中声明可能抛出的异常类型，throw用于手动抛出一个异常，try-catch用于捕获并处理异常。在实际开发中，我们应该根据具体情况合理使用这些关键字，以保证程序的健壮性和可靠性。</p>
<p>##异常的自定义和捕获</p>
<p>​		程序员可以自定义异常，继承Exception或其子类，并通过throw手动抛出异常。异常的捕获可以使用try-catch、try-catch-finally或try-with-resource语句。</p>
<p>在Java中，我们可以通过继承Exception类或其子类来自定义异常。例如，我们可以定义一个自定义异常类<code>MyException</code>，它继承自Exception类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在上面的代码中，我们定义了一个自定义异常类<code>MyException</code>，它继承自Exception类。我们在构造方法中传入异常信息，并调用父类的构造方法来初始化异常信息。</p>
<p>​		接下来，我们可以在程序中抛出自定义异常。例如，我们可以定义一个方法<code>divide</code>，它接受两个整数作为参数，并返回它们的商。如果除数为0，则抛出自定义异常<code>MyException</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> divide(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;An error occurred: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;Division by zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在上面的代码中，我们定义了一个静态方法<code>divide</code>，它接受两个整数作为参数，并返回它们的商。如果除数为0，则抛出自定义异常<code>MyException</code>。在调用<code>divide</code>方法时，我们使用try-catch语句来捕获可能抛出的<code>MyException</code>异常。</p>
<p>​		当程序抛出自定义异常时，我们可以使用try-catch语句来捕获并处理异常。例如，我们可以在上面的代码中使用try-catch语句来捕获可能抛出的<code>MyException</code>异常。在catch块中，我们可以打印异常信息或进行其他操作。</p>
<p>​		总之，在Java中，我们可以通过继承Exception类或其子类来自定义异常。自定义异常可以帮助我们更好地组织和管理代码中的异常情况。在程序中抛出自定义异常时，我们可以使用try-catch语句来捕获并处理异常，以保证程序的健壮性和可靠性。</p>
<p>##异常基础总结</p>
<p>​		在使用异常时，应该优先捕获最具体的异常，不要捕获Throwable类或忽略异常，不要记录并抛出异常，不要抛弃原始的异常，不要使用异常控制程序的流程，在finally块中不要使用return。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>优先捕获最具体的异常</p>
</li>
</ul>
<p>​		在Java中，异常类之间存在继承关系。一般来说，我们应该优先捕获最具体的异常，而不是捕获Throwable类或忽略异常。例如，如果我们需要读取一个文件，但文件不存在，则应该捕获FileNotFoundException异常，而不是捕获更通用的IOException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;File not found&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>不要记录并抛出异常</p>
</li>
</ul>
<p>​		有时候，我们可能会在catch块中记录异常信息，并将异常重新抛出。这种做法会导致异常信息丢失，并且增加了代码的复杂性。因此，我们应该避免记录并抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;An error occurred: &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;An error occurred&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>不要抛弃原始的异常</p>
</li>
</ul>
<p>​		有时候，我们可能会在catch块中抛出新的异常，并且不带原始的异常信息。这种做法会导致原始异常信息丢失，并且增加了代码的复杂性。因此，我们应该避免抛弃原始的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;An error occurred&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;An error occurred&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>不要使用异常控制程序的流程</p>
</li>
</ul>
<p>​		异常机制的主要作用是处理异常情况，而不是控制程序的流程。因此，我们应该避免使用异常来控制程序的流程。例如，在循环中使用异常来跳出循环是不好的做法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>在finally块中不要使用return</p>
</li>
</ul>
<p>​		finally块中的代码会在try或catch块中的代码执行完毕后执行，无论是否发生异常。因此，在finally块中使用return语句会导致前面的代码被忽略，从而可能导致不可预期的结果。因此，我们应该避免在finally块中使用return语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，在使用异常时，我们应该遵循上述几个原则，以保证代码的可读性、可维护性和可靠性。</p>
<p>##异常实践</p>
<p>​		在实践中，应该只针对不正常的情况才使用异常，可以在finally块中清理资源或使用try-with-resource语句，尽量使用标准的异常对异常进行文档说明。</p>
<p>下面是一个Java通过JDBC连接MySQL数据库查询数据并在finally里面关闭资源的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立连接</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建PreparedStatement对象</span></span><br><span class="line">            stmt = conn.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE id=?&quot;</span>);</span><br><span class="line">            stmt.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行查询</span></span><br><span class="line">            rs = stmt.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理结果集</span></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                System.out.println(rs.getInt(<span class="string">&quot;id&quot;</span>) + <span class="string">&quot;, &quot;</span> + rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在上面的代码中，我们首先加载了MySQL的JDBC驱动。然后，我们建立了与MySQL数据库的连接，并创建了一个PreparedStatement对象，用于执行查询操作。接着，我们执行查询，并处理结果集。最后，在finally块中关闭了ResultSet、PreparedStatement和Connection对象。</p>
<p>​		通过JDBC连接MySQL数据库查询数据是Java开发中的常见操作。为了保证程序的健壮性和可靠性，我们应该在finally块中关闭资源。</p>
<p>##JVM处理异常的机制</p>
<p>​		JVM会在抛出异常时创建一个异常对象，并将其传递给方法调用栈中的第一个catch块。如果没有catch块捕获这个异常，JVM会终止当前线程并打印异常堆栈信息。</p>
<p>​		当程序执行到可能会抛出异常的代码时，如果发生了异常，JVM会创建一个异常对象，并将其传递给方法调用栈中的第一个catch块。这个异常对象包含了异常的类型、消息和堆栈信息等信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;An exception occurred: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在上面的代码中，我们试图对10进行除以0的操作，这会导致一个ArithmeticException异常被抛出。JVM会创建一个ArithmeticException对象，并将其传递给try块中的catch块。</p>
<p>​		如果没有catch块捕获这个异常，JVM会终止当前线程并打印异常堆栈信息。异常堆栈信息包含了异常的类型、消息和堆栈跟踪信息等信息，用于帮助开发人员定位和解决问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们没有使用try-catch语句来捕获ArithmeticException异常，因此JVM会终止当前线程并打印异常堆栈信息。</p>
<p>​		JVM在抛出异常时会创建一个异常对象，并将其传递给方法调用栈中的第一个catch块。如果没有catch块捕获这个异常，JVM会终止当前线程并打印异常堆栈信息。因此，在编写Java程序时，我们应该合理地使用异常机制，以保证程序的健壮性和可靠性。</p>
<p>##异常是否耗时？</p>
<blockquote>
<p>异常本身不会耗时，但是在异常处理过程中，可能需要进行一些额外的操作，例如记录日志、资源清理等，这些操作可能会耗费时间。</p>
</blockquote>
<p>##为什么会耗时？</p>
<p>​		异常处理过程中可能需要进行一些额外的操作，例如记录日志、资源清理等，这些操作可能会耗费时间。另外，如果异常处理不当，可能会导致性能问题。</p>
<p>​		在Java中，异常本身不会耗时，它只是一个对象，包含了异常的类型、消息和堆栈信息等信息。但是，在异常处理过程中，可能需要进行一些额外的操作，例如记录日志、资源清理等，这些操作可能会耗费时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 记录日志</span></span><br><span class="line">            System.out.println(<span class="string">&quot;An exception occurred: &quot;</span> + e.getMessage());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清理资源</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们使用try-catch语句来捕获ArithmeticException异常，并在catch块中记录日志和清理资源。这些操作都可能会耗费时间。</p>
<p>​		如果程序中存在大量的异常处理逻辑，这些额外的操作可能会对程序的性能产生影响。因此，在编写Java程序时，我们应该尽量减少异常的发生，并合理地处理异常，以保证程序的性能和可靠性。</p>
<p>​		总之，异常本身不会耗时，但是在异常处理过程中，可能需要进行一些额外的操作，例如记录日志、资源清理等，这些操作可能会耗费时间。因此，在编写Java程序时，我们应该合理地使用异常机制，以保证程序的性能和可靠性。</p>
<h1><span id="反射机制">反射机制</span></h1>
<p>##了解反射机制的概念和原理</p>
<p>###反射机制是什么？</p>
<p>​		反射机制是指程序在运行时动态地获取自身信息并进行操作的能力。简单来说，就是程序在运行时能够访问自己的属性和方法，并且可以通过这些属性和方法对自己进行修改和操作。</p>
<p>###反射机制的原理是什么？</p>
<p>​		反射机制的原理是通过获取程序中的类型信息，进而访问该类型的属性和方法。在Java中，可以使用Class类来获取类型信息，通过该类的方法可以访问类型的属性和方法，并且可以通过反射机制来创建对象、调用方法、获取属性等。</p>
<p>###反射机制的优缺点是什么？</p>
<p>​		反射机制的优点是可以让程序在运行时动态地获取类型信息，从而可以实现更加灵活的编程。例如，可以在运行时动态地创建对象、调用方法等。反射机制还可以用于实现框架和工具，例如JUnit测试框架和Spring框架。</p>
<p>​		反射机制的缺点是会降低程序的性能，因为反射调用需要额外的时间来获取类型信息和执行调用操作。此外，反射机制也会破坏代码的封装性和可读性，因为通过反射可以访问私有属性和方法，从而破坏了程序的封装性。</p>
<p>##掌握反射机制的基础知识</p>
<p>###反射机制的主要类和接口</p>
<p>反射机制在Java中主要涉及以下类和接口：</p>
<ol>
<li class="lvl-3">
<p>Class类：表示一个类的类型，通过该类可以获取类的信息和实例化对象。</p>
</li>
<li class="lvl-3">
<p>Constructor类：表示一个类的构造函数，通过该类可以创建对象。</p>
</li>
<li class="lvl-3">
<p>Method类：表示一个类的方法，通过该类可以调用对象的方法。</p>
</li>
<li class="lvl-3">
<p>Field类：表示一个类的属性，通过该类可以获取和设置对象的属性。</p>
</li>
</ol>
<p>###如何获取Class对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>); <span class="comment">// 通过类的全限定名获取Class对象</span></span><br><span class="line">Class&lt;?&gt; cls2 = String.class; <span class="comment">// 通过类字面常量获取Class对象</span></span><br><span class="line">Class&lt;?&gt; cls3 = <span class="keyword">new</span> <span class="title class_">String</span>().getClass(); <span class="comment">// 通过对象的getClass()方法获取Class对象</span></span><br></pre></td></tr></table></figure>
<p>###如何获取类的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类名、包名、父类信息和接口信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> cls.getName();</span><br><span class="line"><span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> cls.getPackage().getName();</span><br><span class="line">Class&lt;?&gt; superClass = cls.getSuperclass();</span><br><span class="line">Class&lt;?&gt;[] interfaces = cls.getInterfaces();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造函数信息</span></span><br><span class="line">Constructor&lt;?&gt;[] constructors = cls.getConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法信息</span></span><br><span class="line">Method[] methods = cls.getMethods();</span><br><span class="line">Method[] declaredMethods = cls.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性信息</span></span><br><span class="line">Field[] fields = cls.getFields();</span><br><span class="line">Field[] declaredFields = cls.getDeclaredFields();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>###如何操作对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) cls.newInstance(); <span class="comment">// 使用无参构造函数创建对象</span></span><br><span class="line">Constructor&lt;?&gt; constructor = cls.getConstructor(String.class); <span class="comment">// 获取有参构造函数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> (String) constructor.newInstance(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 使用有参构造函数创建对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;length&quot;</span>); <span class="comment">// 获取方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>) method.invoke(str); <span class="comment">// 调用方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取和设置属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> cls.getDeclaredField(<span class="string">&quot;value&quot;</span>); <span class="comment">// 获取属性</span></span><br><span class="line">field.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置属性可访问</span></span><br><span class="line"><span class="type">char</span>[] value = (<span class="type">char</span>[]) field.get(str); <span class="comment">// 获取属性值</span></span><br><span class="line">field.set(str, <span class="string">&quot;Hello World&quot;</span>.toCharArray()); <span class="comment">// 设置属性值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>##深入了解反射机制的实现细节</p>
<p>###反射机制的类加载过程</p>
<p>​		Java程序中的类加载过程通常分为三个阶段：加载、链接和初始化。在反射机制中，获取Class对象的过程涉及到类加载的第一个阶段。</p>
<p>​		当使用Class.forName()方法获取Class对象时，会触发类的加载过程。具体来说，类加载器会根据类的全限定名查找类文件，并将其字节码加载到内存中。加载完成后，会生成一个对应的Class对象，该对象包含了该类的类型信息。</p>
<p>###反射机制的性能影响</p>
<p>反射机制的使用会带来一定的性能影响，主要表现在以下方面：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>反射调用需要额外的时间来获取类型信息和执行调用操作，因此比直接调用方法或访问属性要慢。</p>
</li>
<li class="lvl-2">
<p>反射调用无法进行编译期优化，因此会导致代码执行速度更慢。</p>
</li>
<li class="lvl-2">
<p>反射调用可能会破坏代码的封装性和可读性。</p>
</li>
</ul>
<p>###反射机制与泛型的关系</p>
<p>反射机制可以与泛型相结合使用，可以通过反射机制获取泛型信息并进行操作。例如，可以使用ParameterizedType接口获取泛型类型信息，使用TypeVariable接口获取类型变量信息。下面是一个获取泛型信息的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> GenericClass.class.getField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> field.getGenericType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">paramType</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line">            Type[] typeArgs = paramType.getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Type typeArg : typeArgs) &#123;</span><br><span class="line">                System.out.println(typeArg.getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：<code>T</code>。</p>
<p>###反射机制的安全问题</p>
<p>反射机制的使用可能会带来一些安全问题，因为反射调用可以绕过访问控制机制，从而访问私有属性和方法。为了避免这种情况，可以使用setAccessible()方法将属性和方法设置为可访问的，但这样会降低程序的安全性。因此，在使用反射机制时需要谨慎处理，遵循安全编程的原则。</p>
<p>下面是一个使用反射机制访问私有属性的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Person.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) field.get(person);</span><br><span class="line"></span><br><span class="line">        System.out.println(name); <span class="comment">// 输出结果为：Tom</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在上述示例代码中，通过反射机制获取了Person类的私有属性name，并将其值设置为可访问的，从而可以访问私有属性并获取其值。但这种做法会破坏类的封装性和安全性，因此在实际开发中应该尽量避免这种做法。</p>
<p>​		为了避免这种安全问题，可以使用安全管理器（SecurityManager）来控制反射调用的权限。例如，可以定义一个安全策略类，对反射调用进行限制，只允许调用指定的方法和属性。</p>
<p>下面是一个安全策略类的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySecurityManager</span> <span class="keyword">extends</span> <span class="title class_">SecurityManager</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkMemberAccess</span><span class="params">(Class&lt;?&gt; clazz, <span class="type">int</span> which)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (clazz.getName().equals(<span class="string">&quot;com.example.Person&quot;</span>) &amp;&amp; which == Member.PUBLIC) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Access denied&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.setSecurityManager(<span class="keyword">new</span> <span class="title class_">MySecurityManager</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        System.out.println(person.name); <span class="comment">// 抛出SecurityException异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在上述示例代码中，定义了一个安全策略类MySecurityManager，并重写了checkMemberAccess()方法来控制反射调用的权限。当调用Person类的公共成员时，如果没有通过权限检查，则会抛出SecurityException异常。在main()方法中，通过System.setSecurityManager()方法设置了安全管理器，从而对反射调用进行限制。</p>
<p>​		除了使用安全管理器来控制反射调用的权限之外，还可以使用访问控制（Access Control）来保护Java应用程序的安全。</p>
<p>​		访问控制是指Java语言提供的一种安全机制，它可以控制Java应用程序的访问权限，包括文件系统、网络连接、系统属性等。访问控制是建立在Java安全体系结构之上的，其核心思想是基于代码来源的安全机制，也就是说，只有来自可信任源的代码才能访问受保护资源。</p>
<p>​		Java的访问控制是通过Java安全管理器（SecurityManager）实现的，它是Java安全体系结构中的一部分。安全管理器是一个Java类，它可以拦截Java应用程序的系统访问请求，并检查该请求是否符合安全策略。安全策略是一个规则集合，它定义了哪些操作是安全的，哪些操作是危险的，以及如何控制这些操作。</p>
<p>下面是一个使用访问控制来保护Java应用程序安全的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            sm.checkPermission(<span class="keyword">new</span> <span class="title class_">FilePermission</span>(<span class="string">&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;</span>, <span class="string">&quot;read&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在上述示例代码中，首先通过System.getSecurityManager()方法获取系统安全管理器，并调用其checkPermission()方法来检查文件系统的读取权限。如果没有该权限，则会抛出SecurityException异常。接着创建一个Person对象，并将其name属性设置为&quot;Tom&quot;，最后输出name属性的值。由于没有对Person类进行任何反射操作，因此不存在任何安全问题。</p>
<p>##学习反射机制的高级应用</p>
<p>###如何使用反射机制实现动态代理</p>
<p>​		动态代理是一种常用的设计模式，它允许在运行时动态地创建代理对象，从而实现对原对象的间接访问。Java中的动态代理机制是通过反射机制实现的，主要涉及到两个类：Proxy和InvocationHandler。</p>
<p>​		Proxy类是Java提供的一个用于创建代理对象的工具类，它有两个常用的方法：newProxyInstance()和isProxyClass()。其中，newProxyInstance()方法用于创建代理对象，其参数包括：类加载器、实现的接口列表和InvocationHandler接口实现类对象。InvocationHandler接口是用于处理代理对象上的方法调用的接口，通常将代理对象的方法调用转发给另一个对象。</p>
<p>下面是一个使用反射机制实现动态代理的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am a student.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before calling &quot;</span> + method.getName() + <span class="string">&quot; method.&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After calling &quot;</span> + method.getName() + <span class="string">&quot; method.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(student);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">proxy</span> <span class="operator">=</span> (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Person.class &#125;, handler);</span><br><span class="line">        proxy.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在上述示例代码中，首先定义了一个Person接口和其实现类Student。然后定义了一个实现了InvocationHandler接口的MyInvocationHandler类，用于处理代理对象上的方法调用。在Main类中，首先创建一个Student对象，并将其传递给MyInvocationHandler的构造函数。接着使用Proxy类的newProxyInstance()方法创建一个代理对象，并将其转换为Person类型。最后调用代理对象的sayHello()方法，此时代理对象会将方法调用转发给MyInvocationHandler对象进行处理。</p>
<p>###如何使用反射机制实现注解处理器</p>
<p>​		<code>注解处理器</code>是Java提供的一种用于处理注解的机制，它可以通过反射机制获取类、方法、字段等元素上的注解，并对其进行处理。Java中的注解处理器是通过编写注解处理器类来实现的，其核心就是利用反射机制获取注解信息。</p>
<p>下面是一个使用反射机制实现注解处理器的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@MyAnnotation(&quot;Hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAnnotationProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processAnnotations</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(MyAnnotation.class);</span><br><span class="line">            <span class="keyword">if</span> (annotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Method &quot;</span> + method.getName() + <span class="string">&quot; has annotation value: &quot;</span> + annotation.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        Class&lt;?&gt; clazz = myClass.getClass();</span><br><span class="line">        <span class="type">MyAnnotationProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAnnotationProcessor</span>();</span><br><span class="line">        processor.processAnnotations(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​		在上述示例代码中，首先定义了一个MyAnnotation注解，并在MyClass的sayHello()方法上使用了该注解。然后定义了一个处理注解的MyAnnotationProcessor类，该类可以处理MyAnnotation注解，并输出注解信息。</p>
<p>​		在MyAnnotationProcessor类的processAnnotations()方法中，首先获取MyClass类的Class对象，然后使用getDeclaredMethods()方法获取所有声明的方法，接着使用getAnnotation()方法获取每个方法上的注解，并输出注解信息。在Main类中，首先创建了一个MyClass对象，并获取其Class对象。接着创建一个MyAnnotationProcessor对象，并调用其processAnnotations()方法输出注解信息。</p>
<p>​		通过反射机制，我们可以在运行时获取注解的信息并执行相应的操作。注解处理器可以帮助我们实现许多功能，如自定义注解、注解解析器、自动化代码生成等。但是，在使用注解处理器时也需要注意性能问题和安全问题。</p>
<p>###如何使用反射机制实现对象池</p>
<p>对象池是一种常用的设计模式，它可以避免频繁创建和销毁对象的开销，提高程序的性能。Java中的对象池可以通过反射机制来实现，主要涉及到两个类：Array.newInstance()和Class.newInstance()。</p>
<p>Array.newInstance()方法可以创建指定类型和长度的数组对象，而Class.newInstance()方法可以创建指定类的实例对象。使用这两个方法可以实现对象池中对象的创建和回收。</p>
<p>下面是一个使用反射机制实现对象池的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectPool</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; pool;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectPool</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clazz = clazz;</span><br><span class="line">        pool = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            pool.add(createObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">borrowObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">object</span> <span class="operator">=</span> pool.remove(pool.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> createObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnObject</span><span class="params">(T object)</span> &#123;</span><br><span class="line">        pool.add(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">createObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am a student.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ObjectPool&lt;Student&gt; pool = <span class="keyword">new</span> <span class="title class_">ObjectPool</span>&lt;Student&gt;(Student.class, <span class="number">3</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> pool.borrowObject();</span><br><span class="line">        s1.sayHello();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> pool.borrowObject();</span><br><span class="line">        s2.sayHello();</span><br><span class="line">        pool.returnObject(s2);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> pool.borrowObject();</span><br><span class="line">        s3.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例代码中，首先定义了一个ObjectPool泛型类，用于存储对象池中的对象。在ObjectPool类的构造函数中，使用反射机制创建clazz类型的对象，并添加到pool列表中。在borrowObject()方法中，如果pool列表不为空，则从中取出一个对象并返回；否则调用createObject()方法创建一个新的对象并返回。在returnObject()方法中，将对象添加到pool列表中。在createObject()方法中，使用反射机制创建clazz类型的对象。</p>
<p>在Main类中，首先创建一个Student类型的对象池，然后从中借用一个对象并调用其sayHello()方法，接着从中借用另一个对象并调用其sayHello()方法，最后将第二个对象归还给对象池，并再次从对象池中借用一个对象并调用其sayHello()方法。</p>
<p>###如何使用反射机制实现模板方法</p>
<p>​		模板方法是一种常用的设计模式，它定义了一个算法的框架，将算法中的具体步骤延迟到子类中实现。在Java中，可以使用反射机制实现模板方法，主要涉及到两个类：Class.getMethod()和Method.invoke()。</p>
<p>​		Class.getMethod()方法可以获取指定方法名和参数类型的Method对象，而Method.invoke()方法可以调用指定对象的指定方法。使用这两个方法可以实现模板方法中的具体步骤。</p>
<p>下面是一个使用反射机制实现模板方法的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawShape();</span><br><span class="line">        drawLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">drawLine</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Draw a line.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Draw a rectangle.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Draw a circle.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        Class&lt;?&gt; clazz = shape.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">drawShapeMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;drawShape&quot;</span>);</span><br><span class="line">        drawShapeMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        drawShapeMethod.invoke(shape);</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在上述示例代码中，首先定义了一个Shape抽象类，其中包含了一个final的draw()方法和一个抽象的drawShape()方法和一个默认的drawLine()方法。在draw()方法中，调用了drawShape()和drawLine()方法。在子类中实现drawShape()方法即可实现具体的绘制图形操作。</p>
<p>​		在Main类中，首先创建了一个Circle对象，并获取其Class对象。接着使用Class.getDeclaredMethod()方法获取drawShape()方法的Method对象，并使用Method.setAccessible()方法将其访问权限设置为可访问。然后使用Method.invoke()方法调用drawShape()方法实现具体的绘制操作。最后调用shape对象的draw()方法实现模板方法的调用。</p>
<p>​		通过反射机制，我们可以在运行时获取对象的信息并执行相应的操作。反射机制可以帮助我们实现许多复杂的功能，如动态代理、注解处理器、对象池、模板方法等。但是，反射机制也会对程序的性能产生一定的影响，因此在使用反射机制时需要注意性能问题。同时，由于反射机制可以访问和修改对象的私有属性和方法，因此也可能存在一些安全问题，需要在使用时注意防范。</p>
<p>##实践反射机制的应用案例</p>
<p>###反射机制在框架和库中的应用</p>
<p>​		在框架和库中，反射机制经常被用来实现插件化、AOP（面向切面编程）、ORM（对象关系映射）等功能。例如，在Spring框架中，通过反射机制实现了依赖注入、AOP等核心功能。在Hibernate框架中，通过反射机制实现了ORM的功能。</p>
<ol>
<li class="lvl-3">
<p>Spring框架</p>
</li>
</ol>
<p>Spring框架是一个非常流行的Java企业级开发框架，提供了多种常用的开发功能，如依赖注入、AOP、事务管理等。其中，反射机制在Spring框架中的应用非常广泛。</p>
<p>（1）依赖注入</p>
<p>Spring框架的核心之一就是依赖注入（DI）功能。通过依赖注入，Spring框架可以将各个组件之间的依赖关系交给容器来维护，使得组件之间解耦。依赖注入的实现依赖于反射机制，通过反射机制，Spring框架可以动态地创建Bean对象并注入到其他Bean中。</p>
<p>下面是一个简单的示例，通过反射机制实现依赖注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMyService</span><span class="params">(MyService myService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myService = myService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        myService.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyService do something.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyController</span> <span class="variable">myController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyController</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射机制动态创建MyService对象</span></span><br><span class="line">        <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line">        Class&lt;?&gt; clazz = MyService.class;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">            myController.setMyService((MyService)object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        myController.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们首先创建了一个MyController对象，然后通过反射机制动态地创建了一个MyService对象，并将其注入到MyController对象中。最后，调用MyController对象的doSomething()方法，可以看到MyService对象的doSomething()方法被调用了。</p>
<p>（2）AOP</p>
<p>​		AOP（面向切面编程）是Spring框架的另一个核心功能。通过AOP，可以将通用的代码（如日志、事务、安全控制等）与业务逻辑代码分离，使得代码更加简洁、易于维护。在Spring框架中，AOP的实现依赖于反射机制。</p>
<p>下面是一个简单的示例，通过反射机制实现AOP：</p>
<p>首先定义一个接口Subject：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后实现该接口的具体实现类RealSubject：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealSubject request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着定义一个代理类ProxySubject，该类通过反射机制在实现Subject接口的方法调用前后进行一些额外的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxySubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxySubject</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">before</span> <span class="operator">=</span> subject.getClass().getMethod(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">            before.invoke(subject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subject.request();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">after</span> <span class="operator">=</span> subject.getClass().getMethod(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">            after.invoke(subject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在上面的代码中，首先通过反射机制获取代理对象实际所代表的对象的Class对象，然后获取before和after方法，并调用它们。这样，我们就实现了在实现Subject接口的方法调用前后进行一些额外的操作。</p>
<p>最后，我们可以通过如下代码测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">realSubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line"><span class="type">Subject</span> <span class="variable">proxySubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxySubject</span>(realSubject);</span><br><span class="line">proxySubject.request();</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RealSubject request</span><br></pre></td></tr></table></figure>
<p>###反射机制在开源项目中的应用</p>
<p>​		在开源项目中，反射机制也经常被使用。例如，在JUnit中，通过反射机制实现了自动化测试。在Log4j中，通过反射机制实现了配置文件的自动解析。在Apache Struts框架中，通过反射机制实现了Web请求的处理。</p>
<p>###如何编写自己的反射工具</p>
<p>​		如果需要编写自己的反射工具，可以参考Java提供的反射API，使用Class、Method、Field等类来获取类、方法、字段等信息，并使用Constructor、Method等类来创建对象或调用方法。可以使用反射机制实现一些常见的工具，如对象池、动态代理、注解处理器等。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对象池</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectPool</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; pool;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxPoolSize;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectPool</span><span class="params">(<span class="type">int</span> initialPoolSize, <span class="type">int</span> maxPoolSize, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pool = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(initialPoolSize);</span><br><span class="line">        <span class="built_in">this</span>.maxPoolSize = maxPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.clazz = clazz;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; initialPoolSize; i++) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> createNewObject();</span><br><span class="line">            pool.add(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title function_">acquireObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pool.size() &lt; maxPoolSize) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> createNewObject();</span><br><span class="line">                pool.add(obj);</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Pool is full&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> pool.remove(pool.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">releaseObject</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            pool.add(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">createNewObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;T&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在这个对象池中，我们使用了泛型来支持任意类型的对象池，同时使用了反射机制来创建新的对象。在构造函数中，我们需要传入对象池的最大容量、对象类型的Class对象，以及对象池的初始容量。在创建对象时，我们首先尝试从对象池中获取对象，如果对象池为空，则需要创建一个新的对象。而创建新对象的过程则是通过反射机制实现的，我们使用Class对象的getDeclaredConstructor()方法获取类的默认构造方法，然后调用newInstance()方法创建新的对象。最后，我们使用同步方法来保证对象池的线程安全性。</p>
<p>可以通过以下代码测试这个对象池的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ObjectPool&lt;Connection&gt; pool = <span class="keyword">new</span> <span class="title class_">ObjectPool</span>&lt;&gt;(<span class="number">3</span>, <span class="number">5</span>, Connection.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn1</span> <span class="operator">=</span> pool.acquireObject();</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn2</span> <span class="operator">=</span> pool.acquireObject();</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn3</span> <span class="operator">=</span> pool.acquireObject();</span><br><span class="line"></span><br><span class="line">        pool.releaseObject(conn3);</span><br><span class="line">        pool.releaseObject(conn2);</span><br><span class="line">        pool.releaseObject(conn1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn4</span> <span class="operator">=</span> pool.acquireObject();</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn5</span> <span class="operator">=</span> pool.acquireObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;conn1 == conn4 ? &quot;</span> + (conn1 == conn4)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;conn2 == conn5 ? &quot;</span> + (conn2 == conn5)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在这个示例中，我们使用了一个Connection类来模拟对象池中的对象类型，首先创建了3个对象放入对象池中，然后分别获取并释放了这3个对象。在获取新的对象时，我们可以看到如果对象池中有对象，则会从对象池中获取，否则会创建新的对象。最后，我们通过比较对象的引用来验证，新创建的对象是从对象池中获取的还是通过构造方法创建的。</p>
<p>​		在代码中，我们使用了System.identityHashCode()方法来获取对象的哈希码，然后比较两个对象的哈希码是否相等。如果两个对象的哈希码相等，说明它们是同一个对象，即新创建的对象是从对象池中获取的。如果两个对象的哈希码不相等，说明它们是不同的对象，即新创建的对象是通过构造方法创建的。</p>
<p>​		需要注意的是，通过比较对象引用来验证对象是否来自对象池并不是绝对可靠的方法，因为Java中存在一些情况下，同一个对象的哈希码可能会发生变化。因此，在实际应用中，我们需要根据具体的情况来选择合适的验证方法。</p>
<p>###如何使用反射机制提高代码的灵活性和可扩展性</p>
<p>​		使用反射机制可以提高代码的灵活性和可扩展性。例如，在框架中使用反射机制可以实现插件化，让用户可以动态地添加、删除、替换组件。在ORM框架中，使用反射机制可以将Java对象和数据库表进行映射，从而减少代码的重复性。在实现动态代理、注解处理器等功能时，使用反射机制可以提高代码的复用性和可读性，减少重复的代码。</p>
<h1><span id="spi机制">SPI机制</span></h1>
<p>##了解SPI机制的概念和原理</p>
<p>###SPI是什么？</p>
<p>​		SPI（Service Provider Interface）是Java提供的一种服务发现机制，它允许在运行时动态地加载实现某个特定接口的类。SPI主要用于框架和库的扩展，它通过让框架在运行时动态加载实现了某个接口的类来达到扩展的目的。</p>
<p>###SPI的原理是什么？</p>
<p>​		SPI的原理是基于Java的ClassLoader机制实现的。在Java中，类的加载是由ClassLoader负责的。ClassLoader可以从不同的源加载类，例如从本地文件系统、网络、JAR文件或其他任何资源中加载类。SPI将服务的接口定义放在一个模块中，服务的实现放在另外的模块中，并通过ClassLoader动态地加载实现类。</p>
<p>###SPI机制的优缺点是什么？</p>
<p>​		SPI机制的优点是灵活性高，可以通过简单地添加或替换实现类来扩展应用程序的功能。同时，SPI机制也具有一定的可扩展性和可维护性，因为它将应用程序和具体实现解耦，实现了高内聚、低耦合的目标。</p>
<p>​		SPI机制的缺点是需要程序员手动编写实现类并在META-INF/services目录下创建配置文件，这样会增加代码量和工作量。同时，SPI机制也存在安全风险，因为实现类是由外部提供的，可能存在恶意实现类的风险。</p>
<h3><span id="实现spi机制">实现SPI机制</span></h3>
<h3><span id="使用spi机制的步骤">使用SPI机制的步骤</span></h3>
<ol>
<li class="lvl-3">
<p>定义接口：定义一个接口，声明一些抽象方法。</p>
</li>
<li class="lvl-3">
<p>创建实现类：创建一个或多个实现该接口的类。</p>
</li>
<li class="lvl-3">
<p>配置文件：在META-INF/services/目录下创建一个以接口全限定名为命名的文件，内容为实现类的全限定名，每行一个。</p>
</li>
<li class="lvl-3">
<p>加载配置：使用ServiceLoader类加载配置文件并解析出实现类。</p>
</li>
</ol>
<h3><span id="注意事项">注意事项</span></h3>
<ol>
<li class="lvl-3">
<p>配置文件必须放在META-INF/services/目录下。</p>
</li>
<li class="lvl-3">
<p>配置文件的文件名必须为接口的全限定名。</p>
</li>
<li class="lvl-3">
<p>配置文件中每行只能有一个实现类的全限定名。</p>
</li>
<li class="lvl-3">
<p>实现类必须有一个无参构造函数。</p>
</li>
<li class="lvl-3">
<p>在实现类中可以通过@AutoService注解自动生成配置文件，但需要引入google-auto-service库。</p>
</li>
</ol>
<p>下面我们通过一个示例来演示如何使用SPI机制。</p>
<p>假设我们有一个接口Animal和两个实现类Cat和Dog，我们希望通过SPI机制来加载实现类。</p>
<ol>
<li class="lvl-3">
<p>定义接口</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>创建实现类</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat says hello.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog says hello.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>配置文件</p>
</li>
</ol>
<p>在src/main/resources/META-INF/services/目录下创建一个名为com.example.Animal的文件，内容为实现类的全限定名，每行一个。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Copy</span> codecom.example.Cat</span><br><span class="line">com.example.Dog</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>加载配置</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;Animal&gt; loader = ServiceLoader.load(Animal.class);</span><br><span class="line">        <span class="keyword">for</span> (Animal animal : loader) &#123;</span><br><span class="line">            animal.sayHello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Cat</span> says hello.</span><br><span class="line">Dog says hello.</span><br></pre></td></tr></table></figure>
<p>可以看到，我们使用SPI机制成功加载了实现类，并调用了sayHello()方法。</p>
<p>SPI机制的优点在于可以通过配置文件来动态指定实现类，从而实现灵活的扩展和替换。缺点在于实现类必须有一个无参构造函数，且无法传递参数。</p>
<p>##掌握SPI机制的使用方式</p>
<p>###SPI机制的主要接口和类</p>
<p>​		在Java中，SPI（Service Provider Interface）是一种面向接口编程的方式，它是一组标准的Java API，用于在运行时发现和加载实现某个接口的服务提供者。</p>
<p>SPI机制的主要接口和类包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>ServiceLoader类：该类是Java提供的用于加载和查找服务提供者实现的工具类。它通过读取类路径下的META-INF/services目录中的配置文件，自动加载并实例化配置文件中指定的服务提供者实现类。</p>
</li>
<li class="lvl-2">
<p>Provider接口：该接口是服务提供者实现类需要实现的接口。它通常是一个空接口，用于标识服务提供者实现类的身份。</p>
</li>
</ul>
<p>###如何创建和配置SPI实现</p>
<p>要创建和配置SPI实现，需要进行以下步骤：</p>
<ol>
<li class="lvl-3">
<p>创建一个服务接口：定义一个服务接口，用于描述该服务的功能和方法。例如，定义一个数据库访问接口：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DatabaseAccess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>创建一个服务提供者实现类：实现服务接口，并在该实现类中添加一个名为<code>META-INF/services/服务接口全限定名</code>的文件。该文件中包含了该服务提供者实现类的全限定名。例如，创建一个MySQL数据库访问服务提供者实现类：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLDatabaseAccess</span> <span class="keyword">implements</span> <span class="title class_">DatabaseAccess</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Connect to MySQL database</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Disconnect from MySQL database</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Check if connected to MySQL database</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>在该实现类的<code>META-INF/services/服务接口全限定名</code>文件中添加以下内容：</p>
</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.example.DatabaseAccess</span><br><span class="line">com.example.MySQLDatabaseAccess</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>使用ServiceLoader类加载服务提供者实现类：使用ServiceLoader类加载服务提供者实现类，可以通过以下代码实现：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;DatabaseAccess&gt; loader = ServiceLoader.load(DatabaseAccess.class);</span><br><span class="line"><span class="keyword">for</span> (DatabaseAccess databaseAccess : loader) &#123;</span><br><span class="line">    <span class="comment">// Do something with databaseAccess</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="如何获取spi实现">如何获取SPI实现</span></h3>
<p>要获取SPI实现，只需要使用ServiceLoader类即可。ServiceLoader类提供了以下方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>load(Class&lt;S&gt; service)</code>：加载指定接口的服务提供者实现。</p>
</li>
<li class="lvl-2">
<p><code>reload()</code>：重新加载所有的服务提供者实现。</p>
</li>
<li class="lvl-2">
<p><code>iterator()</code>：获取服务提供者实现的迭代器。</p>
</li>
</ul>
<p>以下代码展示了如何获取MySQL数据库访问服务提供者实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;DatabaseAccess&gt; loader = ServiceLoader.load(DatabaseAccess.class);</span><br><span class="line"><span class="keyword">for</span> (DatabaseAccess databaseAccess : loader) &#123;</span><br><span class="line">    <span class="keyword">if</span> (databaseAccess <span class="keyword">instanceof</span> MySQLDatabaseAccess) &#123;</span><br><span class="line">        <span class="type">MySQLDatabaseAccess</span> <span class="variable">mySQLDatabaseAccess</span> <span class="operator">=</span> (MySQLDatabaseAccess) databaseAccess;</span><br><span class="line">        mySQLDatabaseAccess.connect();</span><br><span class="line">        <span class="comment">// Do something with mySQLDatabaseAccess</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，ServiceLoader类加载了DatabaseAccess接口的所有实现类，然后使用forEach()方法遍历所有实现类，并调用其方法进行数据库操作。</p>
<p>SPI机制在实际项目中的应用非常广泛，常见的应用场景有：</p>
<ol>
<li class="lvl-3">
<p>日志框架。例如SLF4J、Log4j等都使用了SPI机制，让用户自由选择使用不同的实现库。</p>
</li>
<li class="lvl-3">
<p>数据库访问框架。例如Mybatis、Hibernate等都使用了SPI机制，让用户自由选择使用不同的数据库驱动。</p>
</li>
<li class="lvl-3">
<p>RPC框架。例如Dubbo、Motan等都使用了SPI机制，让用户自由选择使用不同的序列化协议、负载均衡算法等。</p>
</li>
<li class="lvl-3">
<p>容器框架。例如Spring、Guice等都使用了SPI机制，让用户自由选择使用不同的依赖注入、AOP等实现。</p>
</li>
</ol>
<p>总之，SPI机制在Java开发中有着广泛的应用，可以让应用程序更加灵活、可扩展。但是，需要注意的是，SPI机制的实现需要遵循一定的规范，否则可能会引发一些问题。同时，SPI机制也有一些缺陷，例如无法在运行时动态添加实现类等，需要开发者在实际应用中进行权衡和选择。</p>
<p>##深入了解SPI机制的实现细节</p>
<p>###SPI实现的加载过程</p>
<p>​		SPI机制的实现需要遵循一定的规则，主要是在META-INF/services目录下创建以接口的全限定名命名的文件，并将实现类的全限定名按行写入该文件。例如，如果我们有一个名为com.example.MyService的接口，那么在META-INF/services目录下应该创建一个名为com.example.MyService的文件，并将实现类的全限定名写入该文件。</p>
<p>SPI机制的加载过程主要涉及以下步骤：</p>
<ol>
<li class="lvl-3">
<p>当应用程序调用ServiceLoader.load(service)方法时，ServiceLoader类会通过当前线程的上下文类加载器（context class loader）来加载服务提供者配置文件。</p>
</li>
<li class="lvl-3">
<p>ServiceLoader类会将服务提供者配置文件中的每一行作为一个服务实现类的全限定名，使用类加载器加载并实例化这些类，最后返回实现了该服务接口的所有对象的集合（Lazy Loading）。</p>
</li>
<li class="lvl-3">
<p>当应用程序需要使用服务时，可以通过ServiceLoader.iterator()方法获取一个迭代器，遍历并使用服务提供者的实现。</p>
</li>
</ol>
<p>###如何在META-INF/services目录下注册SPI实现</p>
<p>​		在META-INF/services目录下注册SPI实现需要创建以接口的全限定名命名的文件，并将实现类的全限定名按行写入该文件。例如，如果我们有一个名为com.example.MyService的接口，那么在META-INF/services目录下应该创建一个名为com.example.MyService的文件，并将实现类的全限定名写入该文件。</p>
<p>​		以DatabaseAccess接口为例，我们可以在META-INF/services目录下创建名为com.example.DatabaseAccess的文件，并将实现类的全限定名按行写入该文件，如下所示：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.example.DatabaseAccessImpl1</span><br><span class="line">com.example.DatabaseAccessImpl2</span><br></pre></td></tr></table></figure>
<p>###如何使用SPI机制加载不同的实现</p>
<p>​		使用SPI机制加载不同的实现可以通过以下代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;DatabaseAccess&gt; serviceLoader = ServiceLoader.load(DatabaseAccess.class);</span><br><span class="line"><span class="keyword">for</span> (DatabaseAccess databaseAccess : serviceLoader) &#123;</span><br><span class="line">    databaseAccess.queryData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		通过ServiceLoader.load(DatabaseAccess.class)方法加载指定接口的实现，并通过迭代器遍历获取实现对象，即可使用不同的实现。</p>
<p>###如何避免SPI机制的安全问题</p>
<p>​		SPI机制存在安全问题，因为SPI的实现类是由应用程序的上下文类加载器加载的，而如果存在恶意的SPI实现，它可能会通过修改ClassPath的方式来影响应用程序。为了避免SPI机制的安全问题，可以考虑以下几个方面：</p>
<ol>
<li class="lvl-3">
<p>验证实现类的合法性：SPI实现类必须是提供者定义的、公开可见的、具有无参构造函数并实现了SPI接口，如果不符合这些条件则应该抛出异常或忽略掉该实现类。</p>
</li>
<li class="lvl-3">
<p>防止恶意实现类：SPI实现类在被加载时，其构造函数可能会被执行，因此应该避免在构造函数中执行任何具有副作用的代码，以防止恶意实现类的攻击。</p>
</li>
<li class="lvl-3">
<p>使用安全沙箱机制：可以使用Java提供的安全沙箱机制，对SPI实现类的代码进行隔离和控制，防止恶意实现类对系统进行攻击。</p>
</li>
<li class="lvl-3">
<p>定期更新SPI实现：由于SPI实现通常是通过外部库或框架提供的，因此应该定期更新这些库或框架，以确保其包含的SPI实现都是安全的。</p>
</li>
<li class="lvl-3">
<p>不依赖SPI实现的具体实现类：在代码中不应该直接依赖于SPI实现的具体实现类，而应该通过接口或抽象类来定义API，以便在需要时更换不同的实现类。</p>
</li>
</ol>
<p>##学习SPI机制的高级应用</p>
<p>###如何扩展和定制SPI机制</p>
<p>SPI机制在Java平台上已经得到广泛的应用，而在某些场景下，我们可能需要扩展和定制SPI机制以满足特定的需求。下面介绍一些常见的扩展和定制方法：</p>
<ol>
<li class="lvl-3">
<p>自定义SPI接口</p>
</li>
</ol>
<p>可以定义自己的SPI接口，实现SPI机制的扩展和定制。比如，可以定义一个新的SPI接口，实现与标准SPI接口不同的实现机制，或者在标准SPI接口的基础上添加新的功能。</p>
<ol start="2">
<li class="lvl-3">
<p>自定义SPI实现</p>
</li>
</ol>
<p>除了自定义SPI接口之外，也可以自定义SPI实现来扩展和定制SPI机制。这种方式可以在标准SPI实现的基础上，添加自己的实现逻辑，或者修改标准SPI实现的行为。</p>
<ol start="3">
<li class="lvl-3">
<p>自定义SPI配置文件</p>
</li>
</ol>
<p>可以通过自定义SPI配置文件，来扩展和定制SPI机制。SPI配置文件的格式与标准的SPI配置文件相同，只是内容不同。在自定义SPI配置文件中，可以定义新的SPI实现，或者修改标准SPI实现的行为。</p>
<p>###如何使用SPI机制实现插件化架构</p>
<p>插件化架构是一种通过插件扩展系统功能的设计模式。在Java平台上，可以使用SPI机制来实现插件化架构。下面是一个简单的插件化示例：</p>
<p>首先，定义一个插件接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Plugin</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，定义两个插件实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PluginA</span> <span class="keyword">implements</span> <span class="title class_">Plugin</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PluginA.execute() is called.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PluginB</span> <span class="keyword">implements</span> <span class="title class_">Plugin</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PluginB.execute() is called.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，创建一个SPI配置文件<code>META-INF/services/com.example.Plugin</code>，并在其中定义插件实现类：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.example.PluginA</span><br><span class="line">com.example.PluginB</span><br></pre></td></tr></table></figure>
<p>最后，通过ServiceLoader类加载插件实现类，并调用插件的执行方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;Plugin&gt; plugins = ServiceLoader.load(Plugin.class);</span><br><span class="line">        <span class="keyword">for</span> (Plugin plugin : plugins) &#123;</span><br><span class="line">            plugin.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行该程序，可以看到输出结果：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PluginA.execute() is called.</span><br><span class="line">PluginB.execute() is called.</span><br></pre></td></tr></table></figure>
<p>通过SPI机制，我们可以将插件的实现类动态地加载到程序中，从而实现插件化架构。</p>
<p>###如何使用SPI机制实现动态配置</p>
<p>使用SPI机制可以实现动态配置，这是因为在SPI机制中，不同的实现类都通过一定的配置方式注册到META-INF/services目录下，因此可以通过修改或替换META-INF/services目录下的配置文件来实现动态配置。</p>
<p>具体实现方法如下：</p>
<ol>
<li class="lvl-3">
<p>定义接口</p>
</li>
</ol>
<p>首先，需要定义一个接口，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Configurable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Properties properties)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口包含一个configure方法，用于接收配置参数。</p>
<ol start="2">
<li class="lvl-3">
<p>实现接口</p>
</li>
</ol>
<p>在不同的实现类中，可以根据具体需求实现该接口。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfigurableImpl</span> <span class="keyword">implements</span> <span class="title class_">Configurable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">        <span class="comment">// 从properties中读取配置参数，并做相应处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>注册实现类</p>
</li>
</ol>
<p>将实现类的全限定名写入META-INF/services/com.example.Configurable配置文件中。例如，在项目中创建META-INF/services/com.example.Configurable文件，写入以下内容：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.example.MyConfigurableImpl</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>加载并配置实现类</p>
</li>
</ol>
<p>在需要使用实现类的地方，可以使用ServiceLoader类加载实现类，并调用configure方法进行配置。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Configurable&gt; serviceLoader = ServiceLoader.load(Configurable.class);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> loadPropertiesFromConfigFile();</span><br><span class="line"><span class="keyword">for</span> (Configurable configurable : serviceLoader) &#123;</span><br><span class="line">    configurable.configure(properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，首先通过ServiceLoader类加载Configurable接口的实现类，然后从配置文件中读取配置参数，并依次调用每个实现类的configure方法进行配置。</p>
<p>通过修改META-INF/services/com.example.Configurable配置文件，可以动态修改实现类，从而实现动态配置。</p>
<p>###如何使用SPI机制实现服务发现和注册</p>
<p>​		SPI机制也可以用于实现服务发现和注册的功能。服务发现和注册是指在分布式系统中，服务提供者将自己提供的服务注册到服务注册中心，服务消费者从服务注册中心获取可用的服务列表，并调用相应的服务。</p>
<p>​		在Java中，可以使用SPI机制实现服务注册和发现。具体实现方式为，在服务提供者实现接口时，在META-INF/services目录下创建一个以接口全限定名命名的文件，文件中每行填写一个实现类的全限定名，表示这个实现类是服务提供者提供的服务。服务消费者使用ServiceLoader类加载这个接口的实现，获取可用的服务列表，并调用相应的服务。</p>
<p>以下是一个示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务提供者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务提供者实现类1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl1</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserServiceImpl1 login: &quot;</span> + username + <span class="string">&quot;, &quot;</span> + password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务提供者实现类2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserServiceImpl2 login: &quot;</span> + username + <span class="string">&quot;, &quot;</span> + password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务提供者在META-INF/services目录下注册服务</span></span><br><span class="line"><span class="comment">// 文件名为服务接口的全限定名，文件内容为实现类的全限定名</span></span><br><span class="line"><span class="comment">// META-INF/services/com.example.UserService</span></span><br><span class="line"><span class="comment">// com.example.UserServiceImpl1</span></span><br><span class="line"><span class="comment">// com.example.UserServiceImpl2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务消费者使用ServiceLoader类获取服务列表并调用服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;UserService&gt; serviceLoader = ServiceLoader.load(UserService.class);</span><br><span class="line">        <span class="keyword">for</span> (UserService userService : serviceLoader) &#123;</span><br><span class="line">            userService.login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		在这个例子中，服务提供者实现了UserService接口，将自己的实现类注册到META-INF/services/com.example.UserService文件中。服务消费者使用ServiceLoader类加载UserService接口的实现，并调用它们的login方法。这样，服务消费者就可以通过SPI机制发现并使用服务提供者提供的服务了。</p>
<p>​		需要注意的是，服务提供者和消费者需要约定服务接口和SPI文件的格式。如果格式不正确，SPI机制就无法正常工作。同时，服务提供者还需要注意不要将敏感信息泄露到SPI文件中，以免造成安全问题。</p>
<p>##实践SPI机制的应用案例</p>
<p>###SPI机制在Java框架中的应用</p>
<p>SPI机制在Java框架中得到了广泛应用，以下是一些常见的使用场景：</p>
<ol>
<li class="lvl-3">
<p>JDBC驱动：Java中的JDBC规范定义了一组接口，允许应用程序访问不同数据库的统一方式。JDBC驱动程序实现了这些接口。Java应用程序通过SPI机制加载所需的数据库驱动程序。</p>
</li>
<li class="lvl-3">
<p>Servlet容器：Java Servlet API定义了一组接口，用于处理HTTP请求和响应。Web服务器或Servlet容器通过SPI机制加载Servlet API实现，以便可以执行应用程序定义的Servlet。</p>
</li>
<li class="lvl-3">
<p>日志系统：Java中的日志系统允许开发人员在应用程序中记录消息和异常。许多常见的日志系统都使用SPI机制加载不同的日志实现。</p>
</li>
<li class="lvl-3">
<p>Spring框架：Spring框架使用SPI机制实现了许多核心功能，如依赖注入、AOP、事务管理等。</p>
</li>
</ol>
<p>###SPI机制在开源项目中的应用</p>
<p>除了Java框架之外，许多开源项目也使用SPI机制实现插件化、扩展性和可配置性。以下是一些常见的使用场景：</p>
<ol>
<li class="lvl-3">
<p>Elasticsearch：Elasticsearch是一款分布式搜索和分析引擎，使用SPI机制来加载插件。Elasticsearch本身只提供了一组核心功能，如文档存储和搜索。其他功能，如集群管理、安全性和监控等，则由插件实现。</p>
</li>
<li class="lvl-3">
<p>Dubbo：Dubbo是一款高性能、轻量级的RPC框架，使用SPI机制来加载扩展点。Dubbo本身只提供了一组核心功能，如服务注册和发现、负载均衡、容错处理等。其他功能，如协议、序列化、路由等，则由扩展点实现。</p>
</li>
<li class="lvl-3">
<p>Hadoop：Hadoop是一款分布式计算框架，使用SPI机制来加载各种文件系统。Hadoop支持不同类型的文件系统，如HDFS、S3、Swift等。每种文件系统都由独立的模块实现，这些模块通过SPI机制加载。</p>
</li>
</ol>
<p>###如何使用SPI机制实现跨组件的扩展性和可配置性</p>
<p>SPI机制可以帮助实现跨组件的扩展性和可配置性，具体方法如下：</p>
<ol>
<li class="lvl-3">
<p>定义SPI接口，定义需要扩展的功能，并提供接口方法。</p>
</li>
<li class="lvl-3">
<p>实现SPI接口，编写具体的实现逻辑，并在META-INF/services目录下创建对应的配置文件，将实现类的全类名写入配置文件中。</p>
</li>
<li class="lvl-3">
<p>在需要使用SPI功能的组件中，通过ServiceLoader类加载SPI接口的所有实现类，得到实现类的实例，实现扩展性和可配置性。</p>
</li>
</ol>
<p>下面以一个简单的例子说明如何使用SPI机制实现跨组件的扩展性和可配置性：</p>
<ol>
<li class="lvl-3">
<p>定义SPI接口：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataProvider</span> &#123;</span><br><span class="line">    String <span class="title function_">getData</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>实现SPI接口：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDataProvider</span> <span class="keyword">implements</span> <span class="title class_">DataProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 从文件中读取数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;data from file&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在META-INF/services目录下创建文件 “com.example.DataProvider”，并写入 “com.example.FileDataProvider”，表示FileDataProvider是DataProvider的实现类。</p>
<ol start="3">
<li class="lvl-3">
<p>使用SPI功能的组件中加载DataProvider的实现类：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;DataProvider&gt; serviceLoader = ServiceLoader.load(DataProvider.class);</span><br><span class="line">        <span class="keyword">for</span> (DataProvider provider : serviceLoader) &#123;</span><br><span class="line">            System.out.println(provider.getData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过ServiceLoader类加载DataProvider接口的实现类，得到FileDataProvider实例，并调用getData()方法获取数据。</p>
<p>这样，通过SPI机制，可以方便地实现跨组件的扩展性和可配置性，将不同组件的功能进行解耦和灵活配置。</p>

</article>
    
    <div class="trm-reward">
        
            <span class="trm-reward-btn trm-glow" onclick='var qr = document.getElementById("qr"); qr.style.display = (qr.style.display === "none") ? "block" : "none";'>
                <i class="iconfont fas fa-hand-holding-usd"></i>
            </span>
        
        <p class="trm-reward-comment">如果这篇文章对你有帮助，你可以请作者喝一杯蜜雪冰城。</p>
        <div id="qr" style="display:none;">
            
                <div style="display:inline-block">
                    <a rel="noopener noreferrer" href='images/zfbpay.jpg' target='_blank' >
                       <img src="/images/zfbpay.jpg" alt="支付宝" loading="lazy">
                    </a>
                    <p>支付宝</p>
                </div>
            
                <div style="display:inline-block">
                    <a rel="noopener noreferrer" href='images/wechatpay.png' target='_blank' >
                       <img src="/images/wechatpay.png" alt="微信" loading="lazy">
                    </a>
                    <p>微信</p>
                </div>
            
        </div>
    </div>

    
</div>
<div id="post-next-prev" class="row">
    <div class="col-lg-12">
        <!-- title -->
        <h5 class="trm-title-with-divider">
            其他文章
            <span data-number="02"></span>
        </h5>
    </div>
    
    
        <div class="col-lg-6">
    <div class="trm-blog-card trm-scroll-animation" data-scroll data-scroll-offset="40">
        <a href="/2023/03/29/JWT%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/" class="trm-cover-frame trm-anima-link">
            
            
                <img alt="cover" class="no-fancybox" src="https://www.logosc.cn/oss/download/qt/2023/03/30/af4b2a277bc7788300c848c1298edceb.png">
            
        </a>
        
        <div class="trm-card-descr">
            <div class="trm-label trm-category trm-mb-20">
                <a href=" /categories/code/">
                    code
                </a>
            </div>
            <h5>
                <a href="/2023/03/29/JWT%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/" class="trm-anima-link">
                    JWT入门与实践
                </a>
            </h5>
            <div class="trm-divider trm-mb-20 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>23/03/29</li>
                <li>21:03</li>
                
                    <li>3.2k</li>
                
                
                    <li>14</li>
                
            </ul>
        </div>
    </div>
</div>
    
</div>

    

    <div id="giscus-wrap" class="trm-card trm-scroll-animation comment-container" data-scroll data-scroll-offset="50"></div>
<script data-swup-reload-script>
    function loadGiscus() {
        let nowTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light'
        const config = {
            src: 'https://giscus.app/client.js',
            "data-repo": 'Deep-Octopus/blogCommentRepo',
            "data-repo-id": 'R_kgDOJTFKPg',
            "data-category": 'Announcements',
            "data-category-id": 'DIC_kwDOJTFKPs4CVkCu',
            "data-mapping": 'pathname',
            "data-reactions-enabled": '1',
            "data-emit-metadata": '0',
            "data-theme": nowTheme,
            "data-lang": 'zh-CN',
            crossorigin: "anonymous",
            async: true
        }
        let ele = document.createElement('script')
        for (let key in config) {
            ele.setAttribute(key, config[key])
        }
        document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin', ele)
    }

    function changeGiscusTheme() {
        let theme = document.documentElement.classList.contains('dark') ? 'dark' : 'light'

        function sendMessage(message) {
            const iframe = document.querySelector('iframe.giscus-frame');
            if (!iframe) return;
            iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }

        sendMessage({
            setConfig: {
                theme: theme
            }
        });
    }

    loadGiscus();
</script>



                    <div class="trm-divider footer-divider"></div>

                    <!-- footer -->
                    <footer class="trm-scroll-animation" data-scroll data-scroll-offset="50">

    

    
        <div class="trm-footer-item">
            <span>© 2023- 2023</span>
            <span class="footer-separator"data-separator=" · "></span>
            <span class="trm-accent-color">一个很闲的vegetable</span>
        </div>
    

    
        <div class="trm-footer-item">
            <span>
                由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.3.0
            </span>
            <span class="footer-separator" data-separator=" | "></span>
            <span> 
                主题 - 
                <a rel="noopener" href='https://github.com/MaLuns/hexo-theme-async' target='_blank'>Async</a>
                v2.0.4
            </span>
        </div>
      

     

    
        <div class="trm-footer-item">
            我们永远不会止步不前！！！
        </div>
     
</footer>



  <script src='https://unpkg.com/mermaid@8.0.0/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

                    <!-- footer end -->

                </div>
            </div>
        </div>
    </div>
</div>
            <!-- body end -->

            <div class="trm-fixed-container" data-scroll data-scroll-sticky data-scroll-target=".locomotive-scroll__sticky-target" data-scroll-offset="-10">
    
        <div class="trm-fixed-btn" data-title="阅读模式" onclick="asyncFun.switchReadMode()">
            <i class="iconfont fas fa-book-reader"></i>
        </div>
    
    
        <div class="trm-fixed-btn" data-title="单栏和双栏切换" onclick="asyncFun.switchSingleColumn()">
            <i class="iconfont fas fa-arrows-alt-h"></i>
        </div>
    
    <div id="trm-back-top" class="trm-fixed-btn" data-title="回到顶部">
        <i class="iconfont fas fa-arrow-up"></i>
    </div>
</div>
          </div>
        </div>
      </div>
      <!-- scroll container end -->

  </div>
  <!-- app wrapper end -->

  
<div class="trm-search-popup">
    <div class="trm-search-header">
        <span class="trm-search-popup-btn-close">
            <i class="iconfont fas fa-times"></i>
        </span>
    </div>
    <div class="form trm-search-form">
        <input class="trm-search-input" type="text" placeholder="搜索...">
    </div>
    <div class="trm-search-result-container">

    </div>
</div>

  <!-- Plugin -->




    
    
<script src="https://npm.elemecdn.com/locomotive-scroll@4.1.4/dist/locomotive-scroll.min.js"></script>

    
<script src="https://npm.elemecdn.com/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>

    

    

    

    <!-- 数学公式 -->
    
        
<script src="https://npm.elemecdn.com/katex@latest/dist/katex.min.js" data-swup-reload-script></script>

        
            
<script src="https://npm.elemecdn.com/katex@latest/dist/contrib/copy-tex.min.js" data-swup-reload-script></script>

        
        
<script src="https://npm.elemecdn.com/katex@latest/dist/contrib/auto-render.min.js" data-swup-reload-script></script>

        <script data-swup-reload-script>
              window.renderMathInElement(document.body, {
                delimiters: [
                    { left: '$$', right: '$$', display: true },
                    { left: '$', right: '$', display: false },
                    { left: '\\(', right: '\\)', display: false },
                    { left: '\\[', right: '\\]', display: true },
                ],
                ...{"displayMode":true,"output":"htmlAndMathml","strict":false},
            })
        </script>
    

    <!-- 评论插件 -->
    
        

        
    



<!-- CDN -->


    

    

    




    <!-- Service Worker -->
    
    <!-- baidu push -->
    
    <script data-swup-reload-script>
        (function () {
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>



<script id="async-script" src="/js/main.js?v=2.0.4"></script>

</body>

</html>
<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode刷题笔记</title>
    <url>/2023/03/23/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>LeetCode刷题笔记</h1>
<blockquote>
<p>！！！</p>
<p>注：本文不会对某一算法进行很深入，很细致的讲解，博主追求以最少的文字获得更深的理解，全文的都将按照<code>是什么（what？）``为什么（why？）``怎么做（how？）</code>来进行讲解，我们一直都坚持实践是检验认识真理性的唯一标准，好的算法要能真正解决实际问题，不能光是侃侃而谈。本文代码都根据<code>C++</code>来实现，我们一直秉承一个理念：<code>编程语言永远只是工具，重要的是思想</code>。若想细致了解某一算法，可进行专门的学习。</p>
<p>！！！</p>
</blockquote>
<h2 id="回溯算法">回溯算法</h2>
<h3 id="认识">认识</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>是什么：回溯算法也叫<code>回溯搜索法</code>，就是一种搜索方式，本质就是<code>穷举</code>或<code>枚举</code>所有可能，如果当前选择不符合条件，就<code>回退一步</code>，尝试其他选择，直到找到符合条件的解或枚举完所有情况。所以有时候<code>效率</code>也不会很高，一般都以<code>递归函数</code>实现，<code>回溯</code>和<code>递归</code>相辅相成。</p>
</li>
<li class="lvl-2">
<p>为什么：回溯算法的<code>基本思想</code>是：从问题的某一种状态开始搜索，每次搜索时都尝试<code>所有可能</code>的下一步状态，直到找到<code>一个解</code>或者所有可能的状态都被尝试过。如果找到了一个解，就返回；否则，回溯到上一个状态，继续搜索。回溯算法的<code>时间复杂度</code>通常很<code>高</code>，因为它需要穷举所有可能的情况。但是，在某些情况下，回溯算法是最优解，因为它可以找到所有解。</p>
</li>
<li class="lvl-2">
<p>怎么做：回溯算法的实现通常使用<code>递归</code>。具体来说，可以定义一个递归函数，该函数<code>接收当前状态</code>作为参数，并<code>尝试所有可能</code>的下一步状态。如果找到了一个解，就返回；否则，<code>回溯</code>到上一个状态，继续搜索。在递归函数中，需要注意以下两点：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>定义递归函数的<code>参数</code>和<code>返回值</code>。通常情况下，递归函数的参数包括<code>当前状态</code>和<code>已经搜索到的解</code>，返回值为<code>已经搜索到的解</code>。</p>
</li>
<li class="lvl-4">
<p>在递归函数中，需要判断当前状态是否满足要求。如果满足要求，就将当前状态加入已经搜索到的解中，并返回；否则，继续搜索。</p>
</li>
</ul>
</li>
</ul>
<p>​	根据上述特点，我们很容易可以得到一个回溯算法的程序模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (一种情况 : 当前层的所有情况(若比作N叉树，就是当前层的所有结点)) &#123;</span><br><span class="line">        处理该情况</span><br><span class="line">        <span class="built_in">backtracking</span>(路径, 下一个选择列表);<span class="comment">//递归过程</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实践">实践</h3>
<h4 id="77-组合">77.组合</h4>
<p><strong><a href="https://leetcode.cn/problems/combinations/description/">题目链接</a></strong></p>
<p><strong>题目：</strong></p>
<p>​	给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>​	你可以按 <strong>任何顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>1 &lt;= n &lt;= 20</code></p>
</li>
<li class="lvl-2">
<p><code>1 &lt;= k &lt;= n</code></p>
</li>
</ul>
<p><strong>题解：</strong></p>
<p>​		当看到这个题，我们的本能反应就是：哎，这不就是高中学的那个排列组合里面的组合吗？ 好像是 $C_n^m$ 来着，就是从n个数字里面选择由m个数字所组成的所有组合嘛。但是我们这不是数学题，不然就没意思了，那我们来好好分析一下吧，看我们能怎么解决它：</p>
<p>​		我们可以很容易想到：如果有n个数字，我们现在要获得m个数字组成的所有组合，我们可以先在n个数字里面先取一个数字，然后再在剩下的$n-1$个数字里面再取一个数字……以此类推，我们最后可以取到m个数字，这就是我们要的所有组合里面的其中一个组合，我们把它放到结果集里面，然后再进行相同的操作，直到取完我们要的所有组合。如果结合回溯算法的树形结构，就是当我从n个数字里面取了一个后，剩下的$n-1$个数字都可以成为这个数字的备选数字，但是考虑到组合没有顺序要求，所以像$[1,2]和[2,1]$这样的组合其实是一样的，所以已经选择过的数字将不能成为后面数字的备选数字。</p>
<p>​		举个例子，假如我们要从$[1,2,3,4]$里面选择个数为3的所有组合，那么我们很容易联想到下面的流程：</p>
<pre class="mermaid">graph TB;
	1 --> 2
	1 --> 3
	1 -.-> 4
	2 --> a(3)
	2 --> b(4)
	3 --> c(4)
	d(2) --> e(3)
	e --> f(4)</pre>
<p>​		总共就四种组合情况</p>
<p>​		现在思想我们已经知道了，让我们试着转换成代码来试试看。我们可以用一个二维结果集$res$来保存我们找到的所有组合，用一个一维的集$path$来进行数字的临时保存，我们这里的终止条件就是当$path$集里面的数字个数达到了$k$个，当满足终止条件就将$path$集里面的数据存入结果集$res$里面， 随后就跳出这个函数，进行回溯操作，如果不满足终止条件，说明个数还没达到要求的个数，我们再取剩下的没有选择过的数字，直到满足终止条件。</p>
<p>​		以下是具体的实现代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">getGroup</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getGroup</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">getGroup</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实只要想清楚了整个流程，想好了用什么算法，代码并不需要很多，就能解决这个问题。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>MySQL数据库基本操作</title>
    <url>/2023/03/23/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1>MySQL基本操作<a href="https://www.runoob.com/sql/sql-quickref.html">SQL 快速参考 | 菜鸟教程 (runoob.com)</a></h1>
<div class="success">
<p><strong>我们开始吧</strong><br>
Let us go！！</p>
</div>
<h2 id="连接数据库">连接数据库</h2>
<blockquote>
<p>以下是从命令行中连接mysql服务器的简单实例：</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">host</span>]<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password:******</span><br></pre></td></tr></table></figure>
<h2 id="创建数据库">创建数据库</h2>
<blockquote>
<p>以下命令简单的演示了创建数据库的过程，数据名为 TUTORIALS:</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">host</span>]<span class="comment"># mysqladmin -u root -p create TUTORIALS</span></span><br><span class="line">Enter password:******</span><br></pre></td></tr></table></figure>
<h3 id="删除数据库">删除数据库</h3>
<blockquote>
<p>以下实例删除数据库TUTORIALS</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">host</span>]<span class="comment"># mysqladmin -u root -p drop TUTORIALS</span></span><br><span class="line">Enter password:******</span><br></pre></td></tr></table></figure>
<h3 id="选择数据库">选择数据库</h3>
<blockquote>
<p>以下实例选取了数据库 TUTORIALS:</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">use TUTORIALS;</span><br></pre></td></tr></table></figure>
<h3 id="创建数据表">创建数据表</h3>
<blockquote>
<p>以下为创建MySQL数据表的SQL通用语法：</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name (column_name column_type);</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tutorials_tbl(</span><br><span class="line">    tutorial_id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    tutorial_title VARCHAR(<span class="number">100</span>) NOT NULL,</span><br><span class="line">    tutorial_author VARCHAR(<span class="number">40</span>) NOT NULL,</span><br><span class="line">    submission_date DATE,</span><br><span class="line">    PRIMARY KEY ( tutorial_id )</span><br><span class="line">    ); )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="删除数据表">删除数据表</h2>
<blockquote>
<p>以下实例删除了数据表tutorials_tbl:</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@host<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password:*******</span><br><span class="line">mysql&gt; use TUTORIALS;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; DROP TABLE tutorials_tbl</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.8</span> sec)</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>
<h2 id="插入数据">插入数据</h2>
<blockquote>
<p>以下为向MySQL数据表插入数据通用的 <strong>INSERT INTO</strong> SQL语法：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name ( field1, field2,...fieldN )</span><br><span class="line">                       <span class="keyword">VALUES</span></span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure>
<p>如果数据是字符型，必须使用单引号或者双引号，如：“value”。</p>
<h2 id="查询数据">查询数据</h2>
<blockquote>
<p>以下为在MySQL数据库中查询数据通用的 SELECT 语法：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> field1, field2,...fieldN table_name1, table_name2...</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br><span class="line">[<span class="keyword">OFFSET</span> M ][LIMIT N]</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</p>
</li>
<li class="lvl-2">
<p>SELECT 命令可以读取一条或者多条记录。</p>
</li>
<li class="lvl-2">
<p>你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据</p>
</li>
<li class="lvl-2">
<p>你可以使用 WHERE 语句来包含任何条件。</p>
</li>
<li class="lvl-2">
<p>你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</p>
</li>
<li class="lvl-2">
<p>你可以使用 LIMIT 属性来设定返回的记录数。</p>
</li>
</ul>
<h2 id="where-子句">where 子句</h2>
<blockquote>
<p>以下是SQL SELECT 语句使用 WHERE 子句从数据表中读取数据的通用语法：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> field1, field2,...fieldN table_name1, table_name2...</span><br><span class="line">[<span class="keyword">WHERE</span> condition1 [<span class="keyword">AND</span> [<span class="keyword">OR</span>]] condition2.....</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</p>
</li>
<li class="lvl-2">
<p>你可以在WHERE子句中指定任何条件。</p>
</li>
<li class="lvl-2">
<p>你可以使用AND或者OR指定一个或多个条件。</p>
</li>
<li class="lvl-2">
<p>WHERE子句也可以运用于SQL的 DELETE 或者 UPDATE 命令。</p>
</li>
<li class="lvl-2">
<p>WHERE 子句类似于程序语言中的if条件，根据 MySQL 表中的字段值来读取指定的数据。</p>
</li>
</ul>
<h1>UPDATE 查询</h1>
<blockquote>
<p>以下是 UPDATE 命令修改 MySQL 数据表数据的通用SQL语法：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> field1<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value1, field2<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value2</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>你可以同时更新一个或多个字段。</p>
</li>
<li class="lvl-2">
<p>你可以在 WHERE 子句中指定任何条件。</p>
</li>
<li class="lvl-2">
<p>你可以在一个单独表中同时更新数据。</p>
</li>
</ul>
<p>当你需要更新数据表中指定行的数据时 WHERE 子句是非常有用的。</p>
<h3 id="DELETE-语句">DELETE 语句</h3>
<blockquote>
<p>以下是SQL DELETE 语句从MySQL数据表中删除数据的通用语法：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果没有指定 WHERE 子句，MySQL表中的所有记录将被删除。</p>
</li>
<li class="lvl-2">
<p>你可以在 WHERE 子句中指定任何条件</p>
</li>
<li class="lvl-2">
<p>您可以在单个表中一次性删除记录。</p>
</li>
</ul>
<p>当你想删除数据表中指定的记录时 WHERE 子句是非常有用的。</p>
<h3 id="LIKE-子句-a">LIKE 子句(%a%)</h3>
<blockquote>
<p>以下是SQL SELECT 语句使用 LIKE 子句从数据表中读取数据的通用语法：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> field1, field2,...fieldN table_name1, table_name2...</span><br><span class="line"><span class="keyword">WHERE</span> field1 <span class="keyword">LIKE</span> condition1 [<span class="keyword">AND</span> [<span class="keyword">OR</span>]] filed2 <span class="operator">=</span> <span class="string">&#x27;somevalue&#x27;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>你可以在WHERE子句中指定任何条件。</p>
</li>
<li class="lvl-2">
<p>你可以在WHERE子句中使用LIKE子句。</p>
</li>
<li class="lvl-2">
<p>你可以使用LIKE子句代替等号(=)。</p>
</li>
<li class="lvl-2">
<p>LIKE 通常与 % 一同使用，类似于一个元字符的搜索。</p>
</li>
<li class="lvl-2">
<p>你可以使用AND或者OR指定一个或多个条件。</p>
</li>
<li class="lvl-2">
<p>你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。</p>
</li>
</ul>
<h2 id="排序">排序</h2>
<blockquote>
<p>以下是SQL SELECT 语句使用 <code>ORDER BY </code>子句将查询数据排序后再返回数据：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> field1, field2,...fieldN table_name1, table_name2...</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> field1, [field2...] [<span class="keyword">ASC</span> [<span class="keyword">DESC</span>]]</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。</p>
</li>
<li class="lvl-2">
<p>你可以设定多个字段来排序。</p>
</li>
<li class="lvl-2">
<p>你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升排列。</p>
</li>
<li class="lvl-2">
<p>你可以添加 WHERE…LIKE 子句来设置条件。</p>
</li>
</ul>
<h2 id="Join">Join</h2>
<blockquote>
<p>你可以在SELECT, UPDATE 和 DELETE 语句中使用Mysql 的 join 来联合多表查询。</p>
</blockquote>
<p>接下来我们就使用MySQL的JOIN来连接以上两张表来读取tutorials_tbl表中所有tutorial_author字段在tcount_tbl表对应的tutorial_count字段值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.tutorial_id, a.tutorial_author, b.tutorial_count</span><br><span class="line">     <span class="keyword">FROM</span> tutorials_tbl a, tcount_tbl b</span><br><span class="line">     <span class="keyword">WHERE</span> a.tutorial_author <span class="operator">=</span> b.tutorial_author;</span><br></pre></td></tr></table></figure>
<h3 id="INNER-JOIN关键字">INNER JOIN关键字</h3>
<blockquote>
<p>INNER JOIN 关键字在表中存在至少一个匹配时返回行。</p>
</blockquote>
<h3 id="SQL-INNER-JOIN-语法">SQL INNER JOIN 语法</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1  </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2 </span><br><span class="line"><span class="keyword">ON</span> table1.column_name <span class="operator">=</span> table2.column_name;</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) </span><br><span class="line"><span class="keyword">FROM</span> table1  </span><br><span class="line"><span class="keyword">JOIN</span> table2 </span><br><span class="line"><span class="keyword">ON</span> table1.column_name <span class="operator">=</span> table2.column_name;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong> : INNER JOIN 与 JOIN 是相同的。</p>
<h3 id="LEFT-JOIN">LEFT JOIN</h3>
<blockquote>
<p>MySQL left join 与 join 有所不同。 MySQL  LEFT  JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">SELECT</span> a.tutorial_id, a.tutorial_author, b.tutorial_count</span><br><span class="line">    -&gt; FROM tutorials_tbl a LEFT JOIN tcount_tbl b</span><br><span class="line">    -&gt; ON a.tutorial_author = b.tutorial_author;</span><br><span class="line">+<span class="literal">-------------</span>+<span class="literal">-----------------</span>+<span class="literal">----------------</span>+</span><br><span class="line">| tutorial_id | tutorial_author | tutorial_count |</span><br><span class="line">+<span class="literal">-------------</span>+<span class="literal">-----------------</span>+<span class="literal">----------------</span>+</span><br><span class="line">|           <span class="number">1</span> | John Poul       |              <span class="number">1</span> |</span><br><span class="line">|           <span class="number">2</span> | Abdul S         |           NULL |</span><br><span class="line">|           <span class="number">3</span> | Sanjay          |              <span class="number">1</span> |</span><br><span class="line">+<span class="literal">-------------</span>+<span class="literal">-----------------</span>+<span class="literal">----------------</span>+</span><br></pre></td></tr></table></figure>
<p>以上实例中使用了LEFT JOIN，该语句会读取左边的数据表tutorials_tbl的所有选取的字段数据，即便在右侧表tcount_tbl中没有对应的tutorial_author字段值。</p>
<h2 id="NULL-值处理">NULL 值处理</h2>
<p>我们已经知道MySQL使用 SQL <code>SELECT </code>命令及<code> WHERE</code> 子句来读取数据表中的数据,但是当提供的查询条件字段为 <code>NULL </code>时，该命令可能就无法正常工作。</p>
<p>为了处理这种情况，MySQL提供了三大运算符:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>IS NULL:</strong> 当列的值是NULL,此运算符返回true。</p>
</li>
<li class="lvl-2">
<p><strong>IS NOT NULL:</strong> 当列的值不为NULL, 运算符返回true。</p>
</li>
<li class="lvl-2">
<p><strong>&lt;=&gt;:</strong> 比较操作符（不同于=运算符），当比较的的两个值为NULL时返回true。</p>
</li>
</ul>
<p>关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。</p>
<p>在MySQL中，NULL值与任何其它值的比较（即使是NULL）永远返回<code>false</code>，即 NULL = NULL 返回false 。</p>
<p>MySQL中处理NULL使用IS NULL和IS NOT NULL运算符。</p>
<p>查找数据表中 tutorial_count 列是否为 NULL，必须使用IS NULL和IS NOT NULL，如下实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT * FROM tcount_tbl</span> </span><br><span class="line">    -&gt; WHERE tutorial_count IS NULL;</span><br><span class="line">+-----------------+----------------+</span><br><span class="line">| tutorial_author | tutorial_count |</span><br><span class="line">+-----------------+----------------+</span><br><span class="line">| mahnaz          |           NULL |</span><br><span class="line">| Jen             |           NULL |</span><br><span class="line">+-----------------+----------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT * from tcount_tbl</span> </span><br><span class="line">    -&gt; WHERE tutorial_count IS NOT NULL;</span><br><span class="line">+-----------------+----------------+</span><br><span class="line">| tutorial_author | tutorial_count |</span><br><span class="line">+-----------------+----------------+</span><br><span class="line">| mahran          |             20 |</span><br><span class="line">| Gill            |             20 |</span><br><span class="line">+-----------------+----------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式">正则表达式</h2>
<blockquote>
<p>MySQL可以通过 <strong>LIKE …%</strong> 来进行模糊匹配。</p>
</blockquote>
<blockquote>
<p>MySQL 同样也支持其他正则表达式的匹配， MySQL中使用 <code>REGEXP </code>操作符来进行正则表达式匹配。</p>
</blockquote>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">^</span> <span class="built_in">$</span> . [...] [<span class="built_in">^</span>...] p1|p2|p3 * + &#123;n&#125; &#123;m,n&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查找name字段中以’st’为开头的所有数据：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT name FROM person_tbl WHERE name REGEXP <span class="string">&#x27;^st&#x27;</span>;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>查找name字段中以’ok’为结尾的所有数据：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT name FROM person_tbl WHERE name REGEXP <span class="string">&#x27;ok$&#x27;</span>;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>查找name字段中包含’mar’字符串的所有数据：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT name FROM person_tbl WHERE name REGEXP <span class="string">&#x27;mar&#x27;</span>;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>查找name字段中以元音字符开头且以’ok’字符串结尾的所有数据：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT name FROM person_tbl WHERE name REGEXP <span class="string">&#x27;^[aeiou]|ok$&#x27;</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="事务">事务</h2>
<blockquote>
<p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个<code>事务</code>！</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>在MySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务</p>
</li>
<li class="lvl-2">
<p>事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行</p>
</li>
<li class="lvl-2">
<p>事务用来管理insert,update,delete语句</p>
</li>
</ul>
<blockquote>
<p>一般来说，事务是必须满足4个条件（<code>ACID</code>）： Atomicity（原子性）、Consistency（稳定性）、Isolation（隔离性）、Durability（可靠性）</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>1、<strong>事务的原子性</strong>:     一组事务，要么成功；要么撤回。</p>
</li>
<li class="lvl-2">
<p>2、<strong>稳定性</strong>： 有非法数据（外键约束之类），事务撤回。</p>
</li>
<li class="lvl-2">
<p>3、<strong>隔离性</strong>:    事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。</p>
</li>
<li class="lvl-2">
<p>4、<strong>可靠性</strong>:    软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit选项 决定什么时候吧事务保存到日志里。</p>
</li>
</ul>
<h3 id="在Mysql控制台使用事务来操作">在Mysql控制台使用事务来操作</h3>
<p>1，开始一个事务</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">start</span> transaction</span><br></pre></td></tr></table></figure>
<p>2, 做保存点</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">save point 保存点名称</span><br></pre></td></tr></table></figure>
<p>3, 操作</p>
<p>4，可以回滚，可以提交，没有问题，就提交，有问题就回滚。</p>
<h2 id="ALTER命令">ALTER命令</h2>
<blockquote>
<p>当我们需要<code>修改数据表名</code>或者<code>修改数据表字段</code>时，就需要使用到MySQL ALTER命令。</p>
</blockquote>
<blockquote>
<p>如下命令使用了 ALTER 命令及 DROP 子句来删除以上创建表的 i 字段：</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl  DROP i;</span><br></pre></td></tr></table></figure>
<p>如果数据表中只剩余一个字段则无法使用DROP来删除字段。</p>
<blockquote>
<p>MySQL 中使用 ADD 子句来想数据表中添加列，如下实例在表 testalter_tbl 中添加 i 字段，并定义数据类型:</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD i INT;</span><br></pre></td></tr></table></figure>
<p>执行以上命令后，i 字段会自动添加到数据表字段的末尾。</p>
<h3 id="如果需要修改字段类型及名称-你可以在ALTER命令中使用-MODIFY-或-CHANGE-子句-。">如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。</h3>
<blockquote>
<p>把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令:</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl MODIFY c CHAR(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段的类型及名称。尝试如下实例：</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl CHANGE i j BIGINT;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>&lt;p如果你现在想把字段 j=“” 从=“” bigint=“” 修改为=“” int，sql语句如下：&lt;=“” p=“”&gt;</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl CHANGE j j INT;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="修改表名">修改表名</h2>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl RENAME TO alter_tbl;</span><br></pre></td></tr></table></figure>
<h2 id="约束">约束</h2>
<blockquote>
<p>NOT    NULL约束<a href="https://www.runoob.com/sql/sql-notnull.html">SQL NOT NULL 约束 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<blockquote>
<p>UNIQUE约束<a href="https://www.runoob.com/sql/sql-unique.html">SQL UNIQUE 约束 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<blockquote>
<p>PRIMARY KEY 约束<a href="https://www.runoob.com/sql/sql-primarykey.html">SQL PRIMARY KEY 约束 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<blockquote>
<p>FOREIGN KEY 约束<a href="https://www.runoob.com/sql/sql-foreignkey.html">SQL FOREIGN KEY 约束 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<blockquote>
<p>CHECK 约束  [<a href="https://www.runoob.com/sql/sql-check.html">SQL CHECK 约束 | 菜鸟教程 (runoob.com)</a>]</p>
</blockquote>
<blockquote>
<p>DEFAULT 约束<a href="https://www.runoob.com/sql/sql-default.html">SQL DEFAULT 约束 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<h2 id="AUTO-INCREMENT-字段">AUTO INCREMENT 字段</h2>
<p>我们通常希望在每次插入新记录时，自动地创建主键字段的值。</p>
<p>我们可以在表中创建一个 auto-increment 字段。</p>
<p>下面的 SQL 语句把 “Persons” 表中的 “ID” 列定义为 auto-increment 主键字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line">(</span><br><span class="line">    ID <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    LastName <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    FirstName <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    Address <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    City <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (ID)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>默认地，AUTO_INCREMENT 的开始值是 1，每条新记录递增 1。</p>
<p>要让 AUTO_INCREMENT 序列以其他的值起始，请使用下面的 SQL 语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Persons AUTO_INCREMENT<span class="operator">=</span><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>要在 “Persons” 表中插入新记录，我们不必为 “ID” 列规定值（会自动添加一个唯一的值）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Persons (FirstName,LastName) <span class="keyword">VALUES</span> (<span class="string">&#x27;Lars&#x27;</span>,<span class="string">&#x27;Monsen&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="MySQL多表操作-一对一-一对多-多对多"><a href="https://www.cnblogs.com/minseo/p/14318464.html">MySQL多表操作(一对一 一对多 多对多)</a></h2>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构与算法</title>
    <url>/2023/03/24/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<hr>
<h1>Java数据结构与算法</h1>
<h2 id="1、绪论">1、绪论</h2>
<blockquote>
<p><code>数据结构</code>是指所涉及的数据元素的集合以及数据元素之间的关系</p>
</blockquote>
<blockquote>
<p>逻辑结构的类型</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>集合</p>
</li>
<li class="lvl-2">
<p>线性结构</p>
</li>
<li class="lvl-2">
<p>树形结构</p>
</li>
<li class="lvl-2">
<p>图形结构</p>
</li>
</ul>
<blockquote>
<p>存储结构</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>顺序存储结构</p>
</li>
<li class="lvl-2">
<p>链式存储结构</p>
</li>
<li class="lvl-2">
<p>索引存储结构</p>
</li>
<li class="lvl-2">
<p>哈希（散列）存储结构</p>
</li>
</ul>
<blockquote>
<p><code>数据类型</code> 是一组性质相同的值的集合和定义在此集合上的一组操作的总称</p>
</blockquote>
<blockquote>
<p>ADT(抽象数据类型)</p>
</blockquote>
<blockquote>
<p>算法</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>有穷性 —&gt;不会出现无限循环</p>
</li>
<li class="lvl-2">
<p>确定性—&gt;不会出现二义性</p>
</li>
<li class="lvl-2">
<p>可行性—&gt;算法每条指令都可执行</p>
</li>
<li class="lvl-2">
<p>输入性—&gt;零个或者多个输入</p>
</li>
<li class="lvl-2">
<p>输出性—&gt;至少一个输出</p>
</li>
</ul>
<blockquote>
<p>算法时间复杂度</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>用T(n)的数量级表示，记作T(n)=O(f(n))</p>
</li>
</ul>
<blockquote>
<p>最好时间复杂度–》min{T(n)}</p>
<p>最坏时间复杂度–》max{T(n)}</p>
<p>平均时间复杂度–》概率</p>
</blockquote>
<h2 id="2、线性表">2、线性表</h2>
<blockquote>
<p>线性表的顺序存储结构—顺序表</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序表泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqListClass</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">initCapacity</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//顺序表初始容量</span></span><br><span class="line">    <span class="keyword">public</span> E[] data; <span class="comment">//存放顺序表中的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> size; <span class="comment">//存放顺序表长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> capacity; <span class="comment">//顺序表的容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqListClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[initCapacity];</span><br><span class="line">        <span class="built_in">this</span>.capacity = initCapacity;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    更改容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateCapacity</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">        E[] newData = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.data.length; i++) &#123;</span><br><span class="line">            newData[i] = <span class="built_in">this</span>.data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.capacity = newCapacity;</span><br><span class="line">        <span class="built_in">this</span>.data = newData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    整体建立顺序表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createList</span><span class="params">(E[] a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.size == <span class="built_in">this</span>.capacity) &#123;</span><br><span class="line">                <span class="built_in">this</span>.updateCapacity(<span class="built_in">this</span>.size * <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            data[i] = a[i];</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    add</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.size == capacity) &#123;</span><br><span class="line">            <span class="built_in">this</span>.updateCapacity(size * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[size] = e;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    设置长度,主要用于缩短长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> nLen)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nLen &lt; <span class="number">0</span> || nLen &gt; <span class="built_in">this</span>.size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;设置长度不在范围内&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.size = nLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    获取线性表中序号为i的元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getElem</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;位置i不在有效范围内&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (E) <span class="built_in">this</span>.data[i];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    setElem();</span></span><br><span class="line"><span class="comment">//    求线性表中第一个为e的元素的序号：getNo(E e);</span></span><br><span class="line"><span class="comment">//    将序号为i和j的元素交换位置：swap(int i, int j);</span></span><br><span class="line"><span class="comment">//    在线性表中序号为i的位置插入元素e:insert(int i, E e);</span></span><br><span class="line"><span class="comment">//    删除线性表中序号为i的元素：delete(int i);</span></span><br><span class="line"><span class="comment">//    toString();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线性表的链式存储结构–链表</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 线性表;</span><br><span class="line"><span class="comment">//单链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表结点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkNode</span>&lt;E&gt; &#123;</span><br><span class="line">    E data;</span><br><span class="line">    LinkNode&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">()</span> &#123;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">(E data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表类</span></span><br><span class="line"><span class="comment">//public class LinkList&#123;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span>&lt;E&gt; &#123;</span><br><span class="line">    LinkNode&lt;E&gt; head; <span class="comment">//存放头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">LinkNode</span>&lt;E&gt;();<span class="comment">//设置头结点</span></span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    将s结点插入到p结点后面--&gt; s.next = p.next;p.next = s;</span></span><br><span class="line"><span class="comment">//    删除结点p的后继结点--&gt; p.next = p.next.next;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建立单链表的方法(下面的代码块均位于LinkList类里)</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>头插法(数据结点次序和数组中数据次序正好相反)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createListF</span><span class="params">(E[]e)</span>&#123;</span><br><span class="line">        LinkNode&lt;E&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e.length();i++)&#123;</span><br><span class="line">        s=<span class="keyword">new</span> <span class="title class_">LinkNode</span>&lt;E&gt;(e[i]); <span class="comment">//循环建立结点</span></span><br><span class="line">        s.next=<span class="built_in">this</span>.head.next;</span><br><span class="line">        <span class="built_in">this</span>.head.next=s;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>尾插法(数据结点次序和数组中数据次序相同)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createListR</span><span class="params">(E[]e)</span>&#123;</span><br><span class="line">        LinkNode&lt;E&gt; s t;</span><br><span class="line">        t=<span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e.length();i++)&#123;</span><br><span class="line">        s=<span class="keyword">new</span> <span class="title class_">LinkNode</span>&lt;E&gt;(e[i]);</span><br><span class="line">        t.next=s;</span><br><span class="line">        t=s;</span><br><span class="line">        &#125;</span><br><span class="line">        t=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线性表的基本运算在单链表中的实现</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>获得序号为i的元素（0&lt;= i &lt;=n-1）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> LinkNode&lt;E&gt; <span class="title function_">getI</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        LinkNode&lt;E&gt; h=<span class="built_in">this</span>.head;</span><br><span class="line">        <span class="type">int</span> j=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;i)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        h=h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>将元素e添加到线性表末尾</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        LinkNode&lt;E&gt; s=<span class="keyword">new</span> <span class="title class_">LinkNode</span>&lt;&gt;(e);</span><br><span class="line">        LinkNode&lt;E&gt; p=head;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next=s;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>求线性表的长度</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        LinkNode&lt;E&gt; p=head;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        size++;</span><br><span class="line">        p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置线性表的长度</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> nLen)</span>&#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="built_in">this</span>.size();</span><br><span class="line">        <span class="keyword">if</span>(nLen&lt; <span class="number">0</span>||nLen&gt;len)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&#x27;err-msg&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(nLen==len)<span class="keyword">return</span>;</span><br><span class="line">        LinkNode&lt;E&gt; p=<span class="built_in">this</span>.getI(nLen-<span class="number">1</span>);<span class="comment">//获取序号为 nLen-1 的结点</span></span><br><span class="line">        p.next=<span class="literal">null</span>;<span class="comment">//截断</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>获取线性表中序号为i的元素（data）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">getElem</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="built_in">this</span>.size();</span><br><span class="line">        <span class="keyword">if</span>(i&lt; <span class="number">0</span>||i&gt;len-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&#x27;err-msg&#x27;</span>);</span><br><span class="line">        LinkNode&lt;E&gt; p=getI(i);<span class="comment">//获取结点</span></span><br><span class="line">        <span class="keyword">return</span>(E)p.data;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置线性表中序号为i的元素setElem(int i,E e)  (与获取相似)</p>
</li>
<li class="lvl-2">
<p>求线性表中第一个为e的元素的逻辑序号</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        LinkNode&lt;E&gt; p=<span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">null</span>&amp;&amp;!p.data.equals(e))&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">null</span>)<span class="keyword">return</span>-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>交换序号为 i 和 j 的元素</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        LinkNode&lt;E&gt; p=getI(i);</span><br><span class="line">        LinkNode&lt;E&gt; q=getI(j);</span><br><span class="line">        E temp=p.data;</span><br><span class="line">        p.data=q.data;</span><br><span class="line">        q.data=temp;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>插入 e 作为第i个元素(序号为i)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i,E e)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt; <span class="number">0</span>||i&gt;size())<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegealArgumentException</span>();</span><br><span class="line">        LinkNode&lt;E&gt; p=<span class="keyword">new</span> <span class="title class_">LinkNode</span>&lt;&gt;(e);</span><br><span class="line">        LinkNode&lt;E&gt; s=getI(i-<span class="number">1</span>);</span><br><span class="line">        s.next=p.next;</span><br><span class="line">        p.next=s;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>删除第i个元素(序号为i)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt; <span class="number">0</span>||i&gt;size())<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegealArgumentException</span>();</span><br><span class="line">        LinkNode&lt;E&gt; p=getI(i-<span class="number">1</span>);</span><br><span class="line">        p.next</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>快慢指针法(返回单链表中间位置元素)(P66)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> E <span class="title function_">middle</span><span class="params">(LinkList&lt;E&gt; l)</span>&#123;</span><br><span class="line">        LinkNode&lt;E&gt; fast=l.head.next;</span><br><span class="line">        LinkNode&lt;E&gt; slow=l.head.next;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="literal">null</span>&amp;&amp;fast.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow.data;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用头插法让单链表l逆序，如（1,2,3,4,5）==&gt;（5,4,3,2,1）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(LinkList&lt;E&gt; l)</span>&#123;</span><br><span class="line">        LinkNode&lt;E&gt; p=l.head.next;<span class="comment">//p指向头结点</span></span><br><span class="line">        LinkNode&lt;E&gt; q;</span><br><span class="line">        l.head.next=<span class="literal">null</span>;<span class="comment">//将l设置为一个空表</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">        q=p.next;<span class="comment">//先用q临时保存p的后继结点</span></span><br><span class="line">        p.next=l.head.next;</span><br><span class="line">        l.head.next=p;</span><br><span class="line">        p=q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将两个递增有序单链表合并为一个递增有序单链表（二路归并 + 尾插法）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LinkNodeClass&lt;Integer&gt; <span class="title function_">Merge</span><span class="params">(LinkListClass&lt;Integer&gt; A,</span></span><br><span class="line"><span class="params">        LinkListClass&lt;Integer&gt; B)</span>&#123;</span><br><span class="line">        LinkNode&lt;Integer&gt; p=A.head.next;</span><br><span class="line">        LinkNode&lt;Integer&gt; q=B.head.next;<span class="comment">//p,q均指向头结点</span></span><br><span class="line">        LinkListClass&lt;Integer&gt; C=<span class="keyword">new</span> <span class="title class_">LinkListClass</span>&lt;&gt;();</span><br><span class="line">        LinkNode&lt;Integer&gt; t=C.head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">null</span>&amp;&amp;q!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.data&lt;q.data)&#123;</span><br><span class="line">        t.next=p;</span><br><span class="line">        t=p;</span><br><span class="line">        p=p.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        t.next=q;</span><br><span class="line">        t=q;</span><br><span class="line">        q=q.next;<span class="comment">//将较小的结点链接到C的末尾</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t.next=<span class="literal">null</span>;<span class="comment">//将C的尾结点的next设置为空</span></span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">null</span>)t.next=p;</span><br><span class="line">        <span class="keyword">if</span>(q!=<span class="literal">null</span>)t.next=q;</span><br><span class="line">        <span class="keyword">return</span> C;<span class="comment">//返回新链表</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>双链表</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双链表的结点泛型类</span></span><br><span class="line"><span class="keyword">public</span> DLinkNode&lt;E&gt;&#123;</span><br><span class="line">        E data;</span><br><span class="line">        DlinkNode&lt;E&gt; prior;<span class="comment">//前驱结点</span></span><br><span class="line">        DlinkNode&lt;E&gt; next;<span class="comment">//后继结点</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DlinkNode</span><span class="params">()</span>&#123;</span><br><span class="line">        prior=<span class="literal">null</span>;</span><br><span class="line">        next=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DlinkNode</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        data=e;</span><br><span class="line">        <span class="built_in">this</span>.DlinkNode();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双链表的泛型类</span></span><br><span class="line"><span class="keyword">public</span> DlinkListClass&lt;E&gt;&#123;</span><br><span class="line">        DlinkNode&lt;E&gt; dhead;<span class="comment">//头结点</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DlinkListClass</span><span class="params">()</span>&#123;</span><br><span class="line">        dhead=<span class="keyword">new</span> <span class="title class_">DLinkNode</span>&lt;E&gt;();</span><br><span class="line">        dhead.prior=<span class="literal">null</span>;</span><br><span class="line">        dhead.next=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头插法建立双链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createListF</span><span class="params">(E[]a)</span>&#123;</span><br><span class="line">        DLinkNode&lt;E&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.length();i++)&#123;</span><br><span class="line">        s=<span class="keyword">new</span> <span class="title class_">DLinkNode</span>&lt;E&gt;(a[i]);</span><br><span class="line">        s.next=dhead.next;<span class="comment">//dhead 为类里面的头结点</span></span><br><span class="line">        <span class="keyword">if</span>(dhead.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        dhead.next.prior=s;</span><br><span class="line">        &#125;</span><br><span class="line">        dhead.next=s;</span><br><span class="line">        s.prior=dhead;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾插法建立双链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createListR</span><span class="params">(E[]a)</span>&#123;</span><br><span class="line">        DLinkNode&lt;E&gt; s;</span><br><span class="line">        t=dhead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.length();i++)&#123;</span><br><span class="line">        s=<span class="keyword">new</span> <span class="title class_">DLinkNode</span>&lt;E&gt;(a[i]);</span><br><span class="line">        t.next=s;</span><br><span class="line">        s.prior=t;</span><br><span class="line">        t=s;</span><br><span class="line">        &#125;</span><br><span class="line">        t.next=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>循环链表</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环单链表泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLinkListClass</span> &#123;</span><br><span class="line">    LinkNode&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClinkListClass</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">LinkNode</span>&lt;E&gt;();</span><br><span class="line">        head.next = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>循环双链表</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDLinkNodeList</span>&lt;E&gt; &#123;</span><br><span class="line">    DLinkNode&lt;E&gt; dhead;<span class="comment">//存放头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CDLinkNodeList &#123;</span><br><span class="line">        dhead = <span class="keyword">new</span> <span class="title class_">DLinkNode</span>&lt;E&gt;();</span><br><span class="line">        dhead.next = dhead;</span><br><span class="line">        dhead.prior = dhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>顺序表和链表的比较</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>基于时间考虑</p>
</li>
</ul>
<p>存储密度 = 结点中数据本身所占用的存储量/整个结点占用的内存量</p>
<p>一般情况下，存储密度越大，存储空间利用率就越大</p>
<p>当线性表长度变化不大，易于事先估计的情况，为了节省内存空间，宜采用顺序表</p>
<p>反之，当变化较大，难以估计其内存大小时，为了节省存储空间，宜采用链表</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>基于时间考虑</p>
</li>
</ul>
<p>在顺序表进行插入删除操作时平均需要移动一半的元素；</p>
<blockquote>
<p>二路归并 + 顺序存储结构求解多项式相加（主要算法）</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>用i，j分别遍历L1和L2有序多项式顺序表的元素，先建立一个空的多项式顺序表L3，在L1，L2都没有遍历完时循环</p>
</li>
<li class="lvl-2">
<ol>
<li class="lvl-7">
<p>若i指向的元素的指数比较大，则根据其系数和指数新建一个元素并将其添加到L3，i++</p>
</li>
<li class="lvl-7">
<p>若j指向的元素的指数比较大，则根据其系数和指数新建一个元素并将其添加到L3，j++</p>
</li>
<li class="lvl-7">
<p>若i和j指向的元素的指数相同，则求出系数之和c，若c != 0,则由该系数和指数新建一个元素并将其添加到L3，否则不新建元素。最后 i++，j++</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>采用链式存储结构求解多想是相加</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个多项式对应的结点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> coef;<span class="comment">//系数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> exp;<span class="comment">//指数</span></span><br><span class="line">    <span class="keyword">public</span> PolyNode next;<span class="comment">//指向下一项</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PolyNode</span><span class="params">()</span> &#123;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PolyNode</span><span class="params">(<span class="type">double</span> coef, <span class="type">int</span> exp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coef = coef;</span><br><span class="line">        <span class="built_in">this</span>.exp = exp;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多项式单链表PolyClass类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyClass</span> &#123;</span><br><span class="line">    PolyNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PolyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">PolyClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.cnblogs.com/youxin/p/3279391.html">对单链表设置一个头结点的作用是什么？</a></p>
</blockquote>
<h2 id="栈和队列">栈和队列</h2>
<blockquote>
<h3 id="栈">栈</h3>
</blockquote>
<p>抽象来说，栈是一种只能在一段进行插入或者删除操作的线性表，允许插入和删除的一段叫做<code>栈顶</code>，另一端叫做<code>栈底</code>，插入操作通常称为<code>进栈</code>或<code>入栈</code>，删除操作通常称为<code>退栈</code>或<code>出栈</code></p>
<p>设n个元素进栈顺序为1,2,3…n，出栈顺序为$p_1$,$p_2$,…$p_n$,若$p_1$ = n,$p_2$ = n-1,…,$p_n$= 1,</p>
<p>即：$p_i$ +$i$ = $n$ + 1, $p_i$ = $n$ - $i$ + 1</p>
<blockquote>
<p>顺序栈</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>顺序栈四要素：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>栈空的条件是 <code>top = -1</code>;</p>
</li>
<li class="lvl-2">
<p>栈满（栈上溢出）的条件是 <code>top = capacity -1</code>   ，采用动态扩容的方法，即栈满时将data数组的容量扩大<code>两倍</code>;</p>
</li>
<li class="lvl-2">
<p>元素e进栈的操作是先将 <code>top+1</code>，然后将元素放在栈顶指针 <code>top</code> 处;</p>
</li>
<li class="lvl-2">
<p>出栈操作先将栈顶指针<code>top</code>处的元素取出，再将<code>top - 1</code>;</p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>顺序栈的泛型类</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">S</span>    qStackClass&lt;E&gt;&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> initcapacity=<span class="number">10</span>;<span class="comment">//初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> capacity;<span class="comment">//存放顺序栈容量</span></span><br><span class="line"><span class="keyword">private</span> E[]data;<span class="comment">//存放顺序栈元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> top;<span class="comment">//存放栈顶指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SqStackClass</span><span class="params">()</span>&#123;</span><br><span class="line">        data=(E[])<span class="keyword">new</span> <span class="title class_">Object</span>[initcapacity];<span class="comment">//强制转换为E类型数组</span></span><br><span class="line">        capacity=initcapacity;</span><br><span class="line">        top=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变栈的容量大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateCapacity</span><span class="params">(<span class="type">int</span> newcapacity)</span>&#123;</span><br><span class="line">        E[] newdata=(E[])<span class="keyword">new</span> <span class="title class_">Object</span>[newcapacity];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;top+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        newdata[i]=data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        capacity=newcapacity;</span><br><span class="line">        data=newdata;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top==capacity-<span class="number">1</span>)&#123;</span><br><span class="line">        updateCapacity(<span class="number">2</span>*(top+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        data[top]=e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">illegalArgumentException</span>(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        E e=data[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">if</span>(capacity&gt;initcapacity&amp;&amp;top+<span class="number">1</span>&lt;capacity/<span class="number">4</span>)&#123;</span><br><span class="line">        updateCapacity(capacity/<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取栈顶元素，但是top指针不移动，只是查看</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">illegalArgumentException</span>(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>(E)data[top];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检查用户输入的括号是否配对</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> e;</span><br><span class="line">        SqStackClass&lt;Character&gt; st=<span class="keyword">new</span> <span class="title class_">SqStackClass</span>&lt;&gt;();<span class="comment">//建立顺序栈</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;str.length)&#123;</span><br><span class="line">        e=str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(e==<span class="string">&#x27;(&#x27;</span>||e==<span class="string">&#x27;&#123;&#x27;</span>||e==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">        st.push(e);<span class="comment">//左括号入栈</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.empty())<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">if</span>(st.peek()!=<span class="string">&#x27;(&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        st.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.empty())<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">if</span>(st.peek()!=<span class="string">&#x27;[&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        st.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.empty())<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">if</span>(st.peek()!=<span class="string">&#x27;&#123;&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>!empty();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断回文字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        SqStackClass&lt;Character&gt; st=<span class="keyword">new</span> <span class="title class_">SqStackClass</span>&lt;&gt;();<span class="comment">//建立顺序栈</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将前半字符入栈</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;n/<span class="number">2</span>)&#123;</span><br><span class="line">        st.push(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//n为奇数跳过最中间的字符</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将后面的一半字符从栈顶开始比较</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        <span class="comment">//取出栈最上面的字符比较</span></span><br><span class="line">        <span class="keyword">if</span>(!str.charAt(i).equals(st.pop()))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>栈的链式存储结构（不用考虑栈满上溢出的情况）</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>栈空的条件为head.next == null, 初始时只有一个头结点</p>
</li>
<li class="lvl-2">
<p>由于只有内存溢出才会出现栈满的情况，所有一般不考虑</p>
</li>
<li class="lvl-2">
<p>元素e入栈时将包含该元素的结点插入作为首结点</p>
</li>
<li class="lvl-2">
<p>出栈操作返回首结点的值并删除该结点</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结点泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkNode</span>&lt;E&gt; &#123;</span><br><span class="line">    E data;</span><br><span class="line">    LinkNode&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">()</span> &#123;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">(E data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链栈泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkStackClass</span>&lt;E&gt;() &#123;</span><br><span class="line">    LinkNode&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkStackClass</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">LinkNode</span>&lt;E&gt;();</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断链栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        LinkNode&lt;E&gt; s = <span class="keyword">new</span> <span class="title class_">LinkNode</span>&lt;&gt;(e);</span><br><span class="line">        s.next = head.next;</span><br><span class="line">        head.next = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">illegalArgumentException</span>(<span class="string">&quot;空栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) head.next.data;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取栈顶元素值</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">illegalArgumentException</span>(<span class="string">&quot;空栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (E) head.next.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>中缀表达式转后缀表达式<a href="https://developer.aliyun.com/article/319924#:~:text=%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A%201.%E9%81%87%E5%88%B0%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%87%BA%EF%BC%88%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%EF%BC%89,2.%E6%A0%88%E4%B8%BA%E7%A9%BA%E6%97%B6%EF%BC%8C%E9%81%87%E5%88%B0%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%85%A5%E6%A0%88%203.%E9%81%87%E5%88%B0%E5%B7%A6%E6%8B%AC%E5%8F%B7%EF%BC%9A%E5%B0%86%E5%85%B6%E5%85%A5%E6%A0%88%204.%E9%81%87%E5%88%B0%E5%8F%B3%E6%8B%AC%E5%8F%B7%EF%BC%9A%E6%89%A7%E8%A1%8C%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%87%BA%E6%A0%88%E7%9A%84%E5%85%83%E7%B4%A0%E8%BE%93%E5%87%BA%EF%BC%8C%E7%9B%B4%E5%88%B0%E5%BC%B9%E5%87%BA%E6%A0%88%E7%9A%84%E6%98%AF%E5%B7%A6%E6%8B%AC%E5%8F%B7%EF%BC%8C%E5%B7%A6%E6%8B%AC%E5%8F%B7%E4%B8%8D%E8%BE%93%E5%87%BA%E3%80%82">【java】中缀表达式转后缀表达式 java实现-阿里云开发者社区 (aliyun.com)</a></p>
</blockquote>
<blockquote>
<h2 id="队列">队列</h2>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>队列的顺序存储结构</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqQueueClass</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MaxSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front, rear;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqQueueClass</span><span class="params">()</span> &#123;</span><br><span class="line">        data = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[MaxSize];</span><br><span class="line">        front = -<span class="number">1</span>;</span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进队，先将rear+1，然后再将元素e放在该位置（总是尾部插入）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rear = MaxSize - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;队满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;</span><br><span class="line">        data[rear] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队，现将front+1，然后再将该位置的元素取出（出队的元素总是从队头出来的）</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;队空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> (E) data[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取队头元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;队空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (E) data[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假溢出</p>
</blockquote>
<p>进队时rear增加，出队rear不变，front增加，当rear==MaxSize-1队满，这种队列中有空位置但是满足队满条件的上溢出称为<code>假溢出</code></p>
<blockquote>
<p>循环队列</p>
</blockquote>
<p>循环队列首尾相连，当队尾指针rear=MaxSize-1时再前进一个位置就到达0位置，这个可以用%（求余）来实现</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>队首指针循环进1：front = (front+1) % MaxSize;</p>
</li>
<li class="lvl-2">
<p>队尾指针循环进1：rear = (rear+1) % MaxSize;</p>
</li>
</ul>
<p>循环队列的队头指针和队尾指针的初始化位置都是0，即front = rear = 0</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>队空条件：rear = front</p>
</li>
<li class="lvl-2">
<p>队满的条件为（rear+1）% MaxSize == front,(相当于试探进队一次，若rear达到了front，则认为队满了)</p>
</li>
<li class="lvl-2">
<p>元素e进队时，rear = (rear+1) % MaxSize,将元素e放置在该位置</p>
</li>
<li class="lvl-2">
<p>元素出队时，front = (front+1) % MaxSize,取出该位置元素</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CSqQueueClass</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MaxSize</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//容量</span></span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front, rear;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CSqQueueClass</span><span class="params">()</span> &#123;</span><br><span class="line">        data = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[MaxSize];</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rear + <span class="number">1</span>) % MaxSize == front) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArguementException</span>(<span class="string">&quot;队满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">        data[rear] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArguementException</span>(<span class="string">&quot;队空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front = (front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">        <span class="keyword">return</span> (E) data[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取队头元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArguementException</span>(<span class="string">&quot;队空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (E) data[(front + <span class="number">1</span>) % MaxSize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>队列的链式存储结构</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结点泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkNode</span>&lt;E&gt; &#123;</span><br><span class="line">    E data;</span><br><span class="line">    LinkNode&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">()</span> &#123;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        data = e;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkQueueClass</span>&lt;E&gt; &#123;</span><br><span class="line">    LinkNode&lt;E&gt; front;</span><br><span class="line">    LinkNode&lt;E&gt; rear;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">()</span> &#123;</span><br><span class="line">        front = <span class="literal">null</span>;</span><br><span class="line">        rear = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>链队队空条件为front = rear = null或者front==null</p>
</li>
<li class="lvl-2">
<p>只有内存溢出才会出现队满，通常不考虑</p>
</li>
<li class="lvl-2">
<p>元素e进队操作：在单链表的尾部插入存放e的s结点，并让队尾指针指向它</p>
</li>
<li class="lvl-2">
<p>元素出队操作：取出队首结点的data值，并将其从链队中删除</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本方法</span></span><br><span class="line"><span class="comment">//队空</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front==<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//进队</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        LinkNode&lt;E&gt; s=<span class="keyword">new</span> <span class="title class_">LinkNode</span>&lt;&gt;(e);</span><br><span class="line">        <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">        front=rear=s;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        E e;</span><br><span class="line">        <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArguementException</span>(<span class="string">&quot;队空&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rear==front)&#123;</span><br><span class="line">        <span class="comment">//只有一个结点</span></span><br><span class="line">        e=(E)front.data;</span><br><span class="line">        front=rear=<span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//多个结点</span></span><br><span class="line">        e=(E)front.data;</span><br><span class="line">        front=front.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//取队头元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArguementException</span>(<span class="string">&quot;队空&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>(E)front.data;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h1>串</h1>
<blockquote>
<p>基本概念</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>串</code>是由零个或多个字符组成的有限序列，里面的单个字符称为串的元素，是构成串的基本单位，串中包含的字符数称为串的长度，当个数为0为<code>空串</code></p>
</li>
</ul>
<blockquote>
<p>串的存储结构</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>顺序存储结构–顺序串</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序串类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqStringClass</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MaxSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">char</span>[] data;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SqStringClass</span><span class="params">()</span> &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">char</span>[MaxSize];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>串的链式存储结构–链串</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链串结点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    LinkNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">()</span> &#123;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        data = ch;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链串类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkStringClass</span> &#123;</span><br><span class="line">    LinkNode head;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkStringClass</span><span class="params">()</span> &#123;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//尾插法插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java 里面的字符串</p>
</blockquote>
<blockquote>
<p>串的模式匹配</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>Brute-Force算法（BF算法）（简单匹配算法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">BF</span><span class="params">(String s, String t)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( i&lt;s.length() &amp;&amp; j&lt;t.length() )&#123;<span class="comment">//s,t都没遍历完时循环</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == t.charAt(j))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i = i-j+<span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= t.length()) <span class="keyword">return</span> ( i-t.length );</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><a href="https://juejin.cn/post/6854573206896918542">KMP算法</a></p>
</li>
<li class="lvl-2">
</li>
<li class="lvl-2">
<p>求模式串的next数组</p>
</li>
<li class="lvl-2">
</li>
<li class="lvl-2">
</li>
</ul>
<pre><code>  1. 对于序号0，规定next[0] = -1;

  2. 对于序号1，置next[1] = 0;

  3. 如果$t_j$有多个相同的前后缀，应该取最长的长度为其next[$t_j$]值；
</code></pre>
<h2 id="递归">递归</h2>
<blockquote>
<p>条件</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>调用次数有限</p>
</li>
<li class="lvl-2">
<p>有终止条件</p>
</li>
<li class="lvl-2">
<p>把一个问题化成很多小问题解决，这些小问题和大问题求解方法一样，只是规模不同</p>
</li>
</ul>
<blockquote>
<p>递归模型</p>
</blockquote>
<p>$f(s_1)=m_1$</p>
<p>$f(s_n)=g(f(s_{n-1}),c_{n-1})$</p>
<p>在递归算法的执行中最长的递归调用的链长称为该算法的<code>递归调用深度</code></p>
<p>例如$n!$的递归算法在求$fun(5)$的递归调用深度为5</p>
<blockquote>
<p>递归算法时间复杂度</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>给出执行时间对应的递推式；</p>
</li>
<li class="lvl-3">
<p>求解递推式得出算法的执行时间$T(n)$;</p>
</li>
<li class="lvl-3">
<p>最后由$T(n)$得出时间复杂度。</p>
</li>
</ol>
<blockquote>
<p>递归算法的空间复杂度</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>根据递归深度得到（同时间复杂度求法，$T(n)–&gt;S(n)$）</p>
</li>
</ul>
<h2 id="数组和稀疏矩阵">数组和稀疏矩阵</h2>
<blockquote>
<p>一维数组</p>
</blockquote>
<p>$LOC(a_i)=LOC(a_0)+i*k$</p>
<blockquote>
<p>d维数组</p>
</blockquote>
<p>对于数组$a[m][n]$，假设每个元素占$k$个存储单元，$LOC(a_{0,0})$表示$a_{0,0}$元素的存储地址</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>行优先</p>
<p>$LOC(a_{i,j})=LOC(a_{0,0})+(i*n+j)*k$</p>
</li>
<li class="lvl-2">
<p>列优先</p>
<p>$LOC(a_{i,j})=LOC(a_{0,0})+(j*m+i)*k$</p>
</li>
</ul>
<blockquote>
<p>稀疏数组</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>利用一个三元组$(i,j,a_{i,j})$来表示，三元组每个元素的类定义如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TupElem</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;<span class="comment">//行号</span></span><br><span class="line">    <span class="type">int</span> c;<span class="comment">//列号</span></span><br><span class="line">    <span class="type">int</span> d;<span class="comment">//元素值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TupElem</span><span class="params">(<span class="type">int</span> r1, <span class="type">int</span> c1, <span class="type">int</span> d1)</span> &#123;</span><br><span class="line">        r = r1;</span><br><span class="line">        c = c1;</span><br><span class="line">        d = d1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>稀疏矩阵三元组类定义</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TupClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> rows;<span class="comment">//行数</span></span><br><span class="line">    <span class="type">int</span> cols;<span class="comment">//列数</span></span><br><span class="line">    <span class="type">int</span> nums;<span class="comment">//非0元素个数</span></span><br><span class="line">    ArrayList&lt;TupElem&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TupClass</span><span class="params">()</span> &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TupElem&gt;();</span><br><span class="line">        nums = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>特殊矩阵的压缩存储</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>对称矩阵的压缩存储</p>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">可以使对称元素共享同一存储空间，可以将$n^2$个元素压缩存储到$n(n+1)/2$ 个元素的空间中。按照行优先存储时仅仅存储其下三角和主对角线部分的元素。</li>
</ul>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">
<p>A中任一元素$a_{i,j}$和B中的元素$b_k$之间的关系如下：</p>
<pre><code>$$ k=\left\&#123;
\begin&#123;matrix&#125;
    &#123;i(i+1) \over 2&#125;+j~~~~~~~i&gt;=j \\
    \\
    \\
    &#123;j(j+1) \over 2&#125;+i~~~~~~~i&lt;j
    \end&#123;matrix&#125;
    \right.
$$
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="树和二叉树">树和二叉树</h2>
<blockquote>
<p>树的基本术语</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>结点的度</code>：树中某个结点的子树的个数</p>
</li>
<li class="lvl-2">
<p><code>树的度</code>：树中各结点的度的最大值（通常将度为m的树称为m次树）</p>
</li>
<li class="lvl-2">
<p><code>分支结点</code>：度不为0的结点</p>
</li>
<li class="lvl-2">
<p><code>叶子结点</code>：度为0 的结点</p>
</li>
<li class="lvl-2">
<p><code>双亲结点</code>、<code>孩子结点</code></p>
</li>
<li class="lvl-2">
<p><code>树的高度（深度）</code>：根节点为第一层，树的最大层级称为树的高度</p>
</li>
</ul>
<blockquote>
<p>树的性质</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>树中的结点数 <code>等于</code> 所有结点的度之和加一</p>
</li>
<li class="lvl-2">
<p>度为m的树的第 $i$ 层上最多有 $m^{i-1}$ 个结点</p>
</li>
<li class="lvl-2">
<p>高度为 $h$ 的 $m$ 次树最多有 ${(m^h-1) \over (m-1)}$个结点</p>
</li>
<li class="lvl-2">
<p>具有 $n$ 个结点的 $m$ 次树的最小高度为 $[log_m(n(m-1)+1)]$</p>
</li>
</ul>
<blockquote>
<p>在$m$次树中计算结点时常用的关系式有：</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>树中所有结点的度之和 = 分支数 = $n-1$</p>
</li>
<li class="lvl-3">
<p>所有结点的度之和 = $n_1 + 2n_2 + ··· + m*n_m$</p>
</li>
<li class="lvl-3">
<p>$n = n_0 + n_1 +···+ n_m$</p>
</li>
</ol>
<blockquote>
<p>树的存储结构</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>双亲存储结构</p>
</li>
</ul>
<p>为一种顺序存储结构，双亲存储结构结点类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PTree</span>&lt;E&gt; &#123;</span><br><span class="line">    E data;<span class="comment">//存放结点的值</span></span><br><span class="line">    <span class="type">int</span> parent;<span class="comment">//存放双亲结点的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>孩子链存储结构</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TSonNode</span>&lt;E&gt; &#123;</span><br><span class="line">    E data;<span class="comment">//结点的值</span></span><br><span class="line">    TSonNode&lt;E&gt;[] sons;<span class="comment">//指向孩子结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二叉树（二分树）</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>二叉树的5中基本形态</p>
<ul class="lvl-2">
<li class="lvl-6">
<p>空二叉树</p>
</li>
<li class="lvl-6">
<p>单结点二叉树</p>
</li>
<li class="lvl-6">
<p>右子树为空的二叉树</p>
</li>
<li class="lvl-6">
<p>左子树为空的二叉树</p>
</li>
<li class="lvl-6">
<p>左右子树都不为空的二叉树<br>
<img src="https://pdai.tech/_images/alg/alg-tree-3.png" alt="二叉树的5种状态" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><code>满二叉树</code>的特点</p>
<ul class="lvl-2">
<li class="lvl-6">
<p>叶子结点都在最下一层；</p>
</li>
<li class="lvl-6">
<p>只有度为0和度为2 的结点；</p>
</li>
<li class="lvl-6">
<p>含$n$个结点的满二叉树的高度为$log_2(n+1)$，叶子结点个数为$(n/2)+1$，度为2的结点个数为$(n/2)$。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><code>完全二叉树</code>的特点：</p>
<ul class="lvl-2">
<li class="lvl-6">
<p>叶子结点只可能出现在最下面两层；</p>
</li>
<li class="lvl-6">
<p>最下一层的叶子结点都依次排列在改层最左边的位置上；</p>
</li>
<li class="lvl-6">
<p>如果有度为 1 的结点，只可能有一个，且该结点最多只有左孩子而无右孩子；</p>
</li>
<li class="lvl-6">
<p>按照层序编号后，一旦出现某结点（编号为$i$）为叶子结点或只有左孩子，则编号大于 $i$ 的结点均为叶子结点。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><code>完全二叉树</code>的计算：</p>
<ul class="lvl-2">
<li class="lvl-6">
<p>结点数为<code>偶</code>——&gt;只有一个分支</p>
</li>
<li class="lvl-6">
<p>结点数为<code>奇</code>——&gt;无单分支</p>
</li>
<li class="lvl-6">
<p>$(n-1)/2$个双分支</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>二叉树的<code>性质</code>:</p>
<ul class="lvl-2">
<li class="lvl-6">
<p>非空二叉树上叶子结点数等于双分支结点数加一；</p>
</li>
<li class="lvl-6">
<p>非空二叉树的第$i$层上最多有$2^{i-1}$个结点$(i&gt;=1)$;</p>
</li>
<li class="lvl-6">
<p>高度为$h$的二叉树最多有$2^h-1$个结点；</p>
</li>
<li class="lvl-6">
<p>具有$n$个结点的完全二叉树的高度为$log_2(n+1)$或$log_2n+1$。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>二叉树的存储结构</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>二叉树的顺序存储结构</p>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">完全二叉树和满二叉树采用顺序存储结构比较合适，既能最大限度<code>节省存储空间</code>，又能利用下标迅速<code>确定二叉树中位置和结点之间的关系</code></li>
</ul>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">编号为$ i $ 的结点的层次为$\lfloor log_2(i+1) \rfloor$</li>
</ul>
</li>
<li class="lvl-2">
<p>二叉树的链式存储结构(二叉链)</p>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">
<p>二叉链结点类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BTNode</span>&lt;E&gt;&#123;</span><br><span class="line">E data;</span><br><span class="line">BTNode lchild;<span class="comment">//指向左结点</span></span><br><span class="line">BTNode rchild;<span class="comment">//指向右结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BTNode</span><span class="params">()</span>&#123;</span><br><span class="line">    lchild=rchild=<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BTNode</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.data = e;</span><br><span class="line">    lchild=rchild=<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二叉树的基本运算</p>
</blockquote>
</li>
</ul>
</li>
<li class="lvl-2">
<p>二叉树的类设计</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BTreeClass</span>&#123;</span><br><span class="line">  BTNode&lt;Character&gt; b;<span class="comment">//根结点</span></span><br><span class="line">  String bstr;<span class="comment">//根结点字符串表达式</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BTreeClass</span><span class="params">()</span>&#123;</span><br><span class="line">      b = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>二叉树的基本运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CreateBTree</span><span class="params">(String str)</span></span><br><span class="line"><span class="comment">//返回二叉树括号表示字符串</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">//查找值为x的结点(递归查找)</span></span><br><span class="line">FindNode(x)</span><br><span class="line"><span class="comment">//求高度h(递归)</span></span><br><span class="line">Height()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>二叉树的遍历</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>先序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历的递归算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PreOrder1</span><span class="params">(BTreeClass bt)</span>&#123;</span><br><span class="line">  PreOrder11(bt.b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PreOrder11</span><span class="params">(BTNode&lt;Character&gt; t)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t!=<span class="literal">null</span>)&#123;</span><br><span class="line">      System.out.print(t.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      PreOrder11(t.lchild);<span class="comment">//先序遍历左子树</span></span><br><span class="line">      PreOrder11(t.rchild);<span class="comment">//先序遍历右子树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历的递归算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InOrder1</span><span class="params">(BTreeClass bt)</span>&#123;</span><br><span class="line">  InOrder11(bt.b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InOrder11</span><span class="params">(BTNode&lt;Character&gt; t)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t!=<span class="literal">null</span>)&#123;</span><br><span class="line">      InOrder11(t.lchild);<span class="comment">//中序遍历左子树</span></span><br><span class="line">      System.out.print(t.data + <span class="string">&quot; &quot;</span>);<span class="comment">//访问根结点</span></span><br><span class="line">      InOrder11(t.rchild);<span class="comment">//中序遍历右子树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历的递归算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PostOrder1</span><span class="params">(BTreeClass bt)</span>&#123;</span><br><span class="line">  PostOrder11(bt.b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PostOrder11</span><span class="params">(BtNode&lt;Character&gt; t)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t!=<span class="literal">null</span>)&#123;</span><br><span class="line">      PostOrder11(t.lchild);<span class="comment">//后序遍历左子树</span></span><br><span class="line">      PostOrder11(t.rchild);<span class="comment">//后序遍历右子树</span></span><br><span class="line">      System.out.print(t.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二叉树的层次遍历</p>
</blockquote>
</li>
<li class="lvl-2">
<p>层次遍历基本步骤</p>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">访问根结点（第一层）</li>
</ul>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">从左到右访问第二层的所有结点</li>
</ul>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">从左到右访问第三层的所有结点，$…$，第$ h $层的所有结点</li>
</ul>
</li>
<li class="lvl-2">
<p>层次遍历算法设计</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">LevelOrder</span><span class="params">(BTreeClass bt)</span>&#123;</span><br><span class="line">  BTNode&lt;Character&gt; p;</span><br><span class="line">  Queue&lt;BTNode&gt; qu = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;BTNode&gt;();</span><br><span class="line">  qu.offer(bt.b);<span class="comment">//根结点进队</span></span><br><span class="line">  <span class="keyword">while</span>(!qu.isEmpty())&#123;<span class="comment">//队列不为空时循环</span></span><br><span class="line">       P = qu.poll();<span class="comment">//出队第一个结点</span></span><br><span class="line">       System.out.print(p.data + <span class="string">&quot; &quot;</span>);<span class="comment">//输出</span></span><br><span class="line">       <span class="keyword">if</span>(p.lchild!=<span class="literal">null</span>)&#123;<span class="comment">//有左孩子，进队</span></span><br><span class="line">          qu.offer(p.lchild);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(p.rchild!=<span class="literal">null</span>)&#123;<span class="comment">//有右孩子，进队</span></span><br><span class="line">          qu.offer(p.rchild);</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于二叉树构造的一些结论</p>
</blockquote>
</li>
<li class="lvl-2">
<p>任何$ n(n&gt;=0) $个不同结点的二叉树都可以由它的中序序列和先序序列唯一地确定</p>
</li>
<li class="lvl-2">
<p>任何$ n(n&gt;=0) $个不同结点的二叉树都可以由它的中序序列和后序序列唯一地确定</p>
</li>
</ul>
<blockquote>
<p>线索二叉树</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>定义对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在<code>某种遍历次序</code>下该结点的<code>前驱结点</code>和<code>后继结点</code>的<code>指针</code>，这些指针称为线索，加上<code>线索</code>的二叉树称为<code>线索二叉树</code>。</p>
</li>
<li class="lvl-2">
<p>区分“前驱结点”和“孩子结点”<br>
<code>标识</code></p>
<p>$$<br>
左标识ltag=\left{<br>
\begin{matrix}<br>
0<s><s>表示lchild指向左孩子结点\\<br>
1</s></s>表示lchild指向前驱结点的线索<br>
\end{matrix}<br>
\right.<br>
$$</p>
</li>
</ul>
<p>$$<br>
右标识ltag=\left{<br>
\begin{matrix}<br>
0<s><s>表示rchild指向右孩子结点\\<br>
1</s></s>表示rchild指向后继结点的线索<br>
\end{matrix}<br>
\right.<br>
$$</p>
<p>每个这样的结点存储结构如下：</p>
<table>
<thead>
<tr>
<th>ltag</th>
<th>lchild</th>
<th>data</th>
<th>rchild</th>
<th>rtag</th>
</tr>
</thead>
</table>
<blockquote>
<p>线索化二叉树（建立线索二叉树）（以下以中序遍历为主）</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>二叉链结点类</p>
</li>
<li class="lvl-2">
<p>左孩子为空</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>^</th>
<th>data</th>
<th>rchild</th>
</tr>
</thead>
</table>
<p>左指针指向中序遍历的<code>直接前驱</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>右孩子为空</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>lchild</th>
<th>data</th>
<th>^</th>
</tr>
</thead>
</table>
<p>右指针指向中序遍历的<code>直接后继</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThNode</span>&#123;</span><br><span class="line">    <span class="type">char</span> data;<span class="comment">//数据</span></span><br><span class="line">    ThNode lchild, rchild;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThNode</span><span class="params">()</span>&#123;</span><br><span class="line">        lchild = rchild = <span class="literal">null</span>;</span><br><span class="line">        ltag = rtag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>中序线索化二叉树类</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadClass</span>&#123;</span><br><span class="line">    ThNode b;<span class="comment">//二叉树根结点</span></span><br><span class="line">    ThNode root;<span class="comment">//线索二叉树的头结点</span></span><br><span class="line">    ThNode pre;<span class="comment">//用于中序线索化，指向中序前驱结点</span></span><br><span class="line">    String bstr;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadClass</span><span class="params">()</span>&#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基本运算</span></span><br><span class="line">    <span class="comment">//建立以root为头结点的中序线索二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createThread</span><span class="params">()</span>&#123;……&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对以P为根结点的二叉树进行中序线索化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Thread</span><span class="params">(ThNode p)</span>&#123;……&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="%22https://zhuanlan.zhihu.com/p/134184036%22">遍历线索二叉树</a>  &lt;—click here to learn</p>
</blockquote>
<blockquote>
<p>哈夫曼树（最优二叉树）（P272）</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>权值越大，离根结点越近</p>
</li>
<li class="lvl-2">
<p>权值越小，离根结点越远</p>
</li>
<li class="lvl-2">
<p>具有$n_0$个叶子结点的哈夫曼树共有$2n_0-1$个结点</p>
</li>
</ul>
<blockquote>
<p>哈夫曼编码</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>在一组字符的哈夫曼编码中，任一字符的哈夫曼编码<code>不可能</code>是另一字符的哈夫曼编码的前缀。</p>
</li>
</ul>
<blockquote>
<p>二叉树与树、森林之间的转换</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>树到二叉树的转换步骤</p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">加线：在各兄弟结点之间加一连线</li>
</ul>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">抹线：对于任意结点，除了其<code>最左子树</code>之外，抹掉该结点与其他子树之间的<code>双亲-孩子</code>关系</li>
</ul>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">调整：（排列整齐）</li>
</ul>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<p>一棵由树转换的二叉树与还原为树</p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">加线：在<code>各结点的双亲</code>与<code>该结点右链</code>上的每个结点之间加一条连线</li>
</ul>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">抹线：抹掉二叉树中所有双亲结点与其右孩子之间的<code>双亲-右孩子</code>关系</li>
</ul>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">调整：（排列整齐）</li>
</ul>
</li>
</ul>
<blockquote>
<p>森林到二叉树的转换及还原</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>森林转换为二叉树</p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">转换：将森林中每一棵树转换为二叉树</li>
</ul>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">连接：将转换后的二叉树根结点相连</li>
</ul>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">调整：（排列整齐）</li>
</ul>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<p>二叉树还原为森林</p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">抹线：抹掉根结点右链上所有<code>双亲-右孩子</code>关系</li>
</ul>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">转换：分别将抹线后的二叉树还原为树</li>
</ul>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">调整：（排列整齐）</li>
</ul>
</li>
</ul>
<h2 id="图">图</h2>
<blockquote>
<p>基本概念</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>图$G$由两个集合$V和E$组成，记为$G=(V,E)$，其中$V$是顶点的有限集合,记为$V(G)$,<br>
$E$是连接两个不同顶点的边的有限集合，记为$E(G)$。<br>
+无向图：在图$G$中，如果代表边的顶点对（或序偶）是无序的，则成$G$为无向图，$–&gt;(a,b)$</p>
</li>
<li class="lvl-2">
<p>有向图：顶点对有序$–&gt;&lt;a,b&gt;和&lt;b,a&gt;$不一样</p>
</li>
</ul>
<blockquote>
<p>基本术语</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>端点和邻接点<br>
$(a,b)–&gt;a,b互为邻接点,a、b顶点称为该边的两个端点$</p>
</li>
<li class="lvl-2">
<p>顶点的度、入度、出度</p>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4"><code>顶点的度</code>：顶点所关联的边的数目</li>
</ul>
</li>
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4"><code>入度、出度</code>：以该顶点为终点的边的数目，反之，以该端点为起点的边的数目为出度若一个图中有$n$个顶点和$e$条边，每个顶点的度为  $ d_i(0&lt;=i&lt;=(n-1))$,则有：</li>
</ul>
</li>
</ul>
<p>$$<br>
e = \frac{1}{2}\sum_{i=0}^{n-1}d_i<br>
$$</p>
<p>相当于一个图中<code>顶点的度之和</code>等于<code>边数</code>的<code>两倍</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>完全图<code>有向图</code>每两个顶点之间都存在着<code>方向相反</code>的<code>两条边</code></p>
</li>
</ul>
<pre class="mermaid">graph TD;
0-->1
1-->0
1-->2
2-->1
2-->3
3-->2
3-->0
0-->3
3-->1
1-->3
0-->2
2-->0</pre>
<p><code>无向图</code>每两个端点之间都存在<code>一条边</code></p>
<pre class="mermaid">graph LR;
0---1
1---2
2---3
3---0
3---1
2---0</pre>
<ul class="lvl-0">
<li class="lvl-2">
<p>稠密图和稀疏图</p>
<ul class="lvl-2">
<li class="lvl-6">当一个图接近万全图时称为稠密图</li>
<li class="lvl-6">当一个图边数较少[有向图$e&lt;&lt;n(n-1),无向图e&lt;&lt;\frac{n(n-1)}{2}$]称为稀疏图</li>
</ul>
</li>
<li class="lvl-2">
<p>子图</p>
<ul class="lvl-2">
<li class="lvl-6">两个图$G=(V,E)和G’=(V’,E’),若V’是V的子集，且E’是E的子集，则G’是G的子图$</li>
</ul>
</li>
<li class="lvl-2">
<p>路径和路径长度</p>
<ul class="lvl-2">
<li class="lvl-6">从$顶点i到顶点j$的一条<code>路径</code>是一个顶点序列$(i,i_1,i_2,…,i_m,j)$</li>
<li class="lvl-6"><code>路径长度</code>是指一条路径上经过的边的数目</li>
<li class="lvl-6"><code>简单路径</code>是指一条路径上除开始点和结束点可以相同外，其余端点均不相同</li>
</ul>
</li>
<li class="lvl-2">
<p>回路和环</p>
<ul class="lvl-2">
<li class="lvl-6">一条路径开始点和结束点相同，该路径被称为<code>回路</code>或<code>环</code></li>
</ul>
</li>
<li class="lvl-2">
<p>连通、连通图、连通分量</p>
<ul class="lvl-2">
<li class="lvl-6">图的任意两个端点都是连通的图称为<code>连通图</code>，否则为<code>非连通图</code></li>
<li class="lvl-6">无向图G的<code>极大连通子图</code>称为G的<code>连通分量</code></li>
</ul>
</li>
<li class="lvl-2">
<p>强连通图和强连通分量</p>
<ul class="lvl-2">
<li class="lvl-6">强连通图：$从顶点i到j和j到i都有路径$</li>
<li class="lvl-6">强连通分量：有向图的极大强连通子图称为该图的强连通分量</li>
</ul>
</li>
<li class="lvl-2">
<p>关结点和重连通图</p>
</li>
<li class="lvl-2">
<p>权和网</p>
<ul class="lvl-2">
<li class="lvl-6">边上带有权的图称为带权图，也称作网</li>
</ul>
</li>
</ul>
<blockquote>
<p>图的存储结构</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>邻接矩阵</p>
<ul class="lvl-2">
<li class="lvl-6">存储方法</li>
<li class="lvl-6">
<ul class="lvl-4">
<li class="lvl-8">G不带权</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>$$<br>
A[i][j]=\left{<br>
\begin{matrix}<br>
1~~~~，(i,j) \in E(G)或者&lt;i,j&gt; \in E(G)\<br>
0~~~~，其他<br>
\end{matrix}<br>
\right.<br>
$$</p>
<ul class="lvl-0">
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">
<ul class="lvl-4">
<li class="lvl-6">G带权</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>$$<br>
A[i][j]=\left{<br>
\begin{matrix}<br>
w_{ij}<s><s>，i \neq j 并且(i,j) \in E(G) 或者 &lt;i,j&gt; \in E(G) \<br>
0</s></s>，i = j \<br>
\infty~~~~,其他<br>
\end{matrix}<br>
\right.<br>
$$</p>
<ul class="lvl-0">
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">
<ul class="lvl-4">
<li class="lvl-6">三个邻接矩阵<br>
$$A_1=\begin{bmatrix}<br>
0&amp;1&amp;0&amp;1&amp;1\<br>
1&amp;0&amp;1&amp;1&amp;0\<br>
0&amp;1&amp;0&amp;1&amp;1\<br>
1&amp;1&amp;1&amp;0&amp;1\<br>
1&amp;0&amp;1&amp;1&amp;0\<br>
\end{bmatrix}$$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>$$A_2=\begin{bmatrix}<br>
0&amp;1&amp;0&amp;1&amp;0\<br>
0&amp;0&amp;1&amp;1&amp;0\<br>
0&amp;0&amp;0&amp;1&amp;1\<br>
0&amp;0&amp;0&amp;0&amp;0\<br>
1&amp;0&amp;0&amp;1&amp;0\<br>
\end{bmatrix}$$</p>
<p>$$A_3=\begin{bmatrix}<br>
0&amp;8&amp;\infty&amp;5&amp;\infty\<br>
\infty&amp;0&amp;3&amp;\infty&amp;\infty\<br>
\infty&amp;\infty&amp;0&amp;\infty&amp;6\<br>
\infty&amp;\infty&amp;9&amp;0&amp;\infty\<br>
\infty&amp;\infty&amp;\infty&amp;\infty&amp;0\<br>
\end{bmatrix}$$</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
